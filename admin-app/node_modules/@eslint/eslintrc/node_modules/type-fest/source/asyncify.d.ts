import { PromiseValue } from './promise-value';
import { SetReturnType } from './set-return-type';

/**
 * Create an async version of the given function type, by boxing the return type in `Promise` while keeping the same parameter types.
 *
 * Use-case: You have two functions, one synchronous and one asynchronous that do the same thing. Instead of having to duplicate the type definition,
 * you can use `Asyncify` to reuse the synchronous type.
 *
 * @example
 * import { Asyncify } from './asyncify';
 *
 * // Synchronous function.
 * function getFooSync<T extends SomeType>(someArg: T): Foo<T> {
 *   // …
 * }
 *
 * type AsyncifiedFooGetter<T extends SomeType> = Asyncify<typeof getFooSync<T>>;
 * //=> type AsyncifiedFooGetter<T extends SomeType> = (someArg: T) => Promise<Foo<T>>;
 *
 * // Same as `getFooSync` but asynchronous.
 * const getFooAsync: AsyncifiedFooGetter<SomeType> = async (someArg) => {
 *   // TypeScript now knows that `someArg` is `T` automatically.
 *   // It also knows that this function must return `Promise<Foo<T>>`.
 *   // If you have `@typescript-eslint/promise-function-async` linter rule enabled, it will even report that "Functions that return promises must be async.".
 *
 *   // …
 * }
 */
export type Asyncify<Fn extends (...args: any[]) => any> = (...args: Parameters<Fn>) => Promise<PromiseValue<ReturnType<Fn>>>;

/**
 * Get the type of the resolved value of a Promise.
 */
export type PromiseValue<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : never;
