type IsAny<T> = 0 extends (1 & T) ? true : false;
type IsNever<T> = [T] extends [never] ? true : false;
type IsUnknown<T> = IsNever<T> extends false ? T extends unknown ? unknown extends T ? IsAny<T> extends false ? true : false : false : false : false;

type IsFunction<T> = T extends (...args: any[]) => any ? true : false;

type SetReturnType<Fn extends (...args: any[]) => any, TypeToReturn> =
  IsFunction<Fn> extends true
    ? Fn extends (this: any, ...args: infer Args) => infer Return
      ? (this: any, ...args: Args) => TypeToReturn
      : never
    : never;

/**
 Create a function type with a return type of your choice and the same parameters as the given function type.

 Use-case: You want to define a wrapped function that returns something different while receiving the same parameters. For example, you might want to wrap a function that can throw an error into one that will return `undefined` instead.

 @example
 ```
 import { SetReturnType } from 'type-fest';

 type MyFunctionThatCanThrow = (foo: SomeType, bar: unknown) => SomeOtherType;

 type MyWrappedFunction = SetReturnType<MyFunctionThatCanThrow, SomeOtherType | undefined>;
 //=> type MyWrappedFunction = (foo: SomeType, bar: unknown) => SomeOtherType | undefined;
 ```
 */
export { SetReturnType };
