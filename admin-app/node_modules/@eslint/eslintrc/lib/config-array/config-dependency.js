/**
 * @fileoverview `ConfigDependency` class.
 *
 * `ConfigDependency` class expresses a loaded parser or plugin.
 *
 * If the parser or plugin was loaded successfully, it has `definition` property
 * and `filePath` property. Otherwise, it has `error` property.
 *
 * When `JSON.stringify()` converted a `ConfigDependency` object to a JSON, it
 * omits `definition` property.
 *
 * `ConfigArrayFactory` creates `ConfigDependency` objects when it loads parsers
 * or plugins.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */

import util from "util";
import type { Parser } from "../../shared/types";
import type { Plugin } from "../../shared/types";

/**
 * The class is to store parsers or plugins.
 * This class hides the loaded object from `JSON.stringify()` and `console.log`.
 * @template T
 */
class ConfigDependency<T> {
  /**
   * Initialize this instance.
   * @param data - The dependency data.
   * @param data.definition - The dependency if the loading succeeded.
   * @param data.original - The original, non-normalized dependency if the loading succeeded.
   * @param data.error - The error object if the loading failed.
   * @param data.filePath - The actual path to the dependency if the loading succeeded.
   * @param data.id - The ID of this dependency.
   * @param data.importerName - The name of the config file which loads this dependency.
   * @param data.importerPath - The path to the config file which loads this dependency.
   */
  constructor(data: {
    definition?: T;
    original?: T;
    error?: Error;
    filePath?: string;
    id: string;
    importerName: string;
    importerPath: string;
  }) {
    if (typeof data !== "object" || data === null) {
      throw new Error("data must be an object");
    }

    /**
     * The loaded dependency if the loading succeeded.
     */
    this.definition = data.definition;

    /**
     * The original dependency as loaded directly from disk if the loading succeeded.
     */
    this.original = data.original;

    /**
     * The error object if the loading failed.
     */
    this.error = data.error;

    /**
     * The loaded dependency if the loading succeeded.
     */
    this.filePath = data.filePath;

    /**
     * The ID of this dependency.
     */
    this.id = data.id;

    /**
     * The name of the config file which loads this dependency.
     */
    this.importerName = data.importerName;

    /**
     * The path to the config file which loads this dependency.
     */
    this.importerPath = data.importerPath;
  }

  /**
   * Serialize this instance to a JSON compatible object.
   */
  toJSON(): Omit<ConfigDependency<T>, "definition" | "original"> {
    const obj = this[util.inspect.custom]();

    // Display `error.message` (`Error#message` is unenumerable).
    if (obj.error instanceof Error) {
      obj.error = { ...obj.error, message: obj.error.message };
    }

    return obj;
  }

  /**
   * Convert this instance to a string for console output.
   */
  [util.inspect.custom](): Omit<ConfigDependency<T>, "definition" | "original"> {
    const {
      definition: _ignore1, // eslint-disable-line no-unused-vars
      original: _ignore2, // eslint-disable-line no-unused-vars
      ...obj
    } = this;

    return obj;
  }

  /**
   * Convert this instance to a string for console output.
   */
  toString(): string {
    return util.inspect(this);
  }
}

/** @typedef {ConfigDependency<Parser>} DependentParser */
/** @typedef {ConfigDependency<Plugin>} DependentPlugin */

export { ConfigDependency };
