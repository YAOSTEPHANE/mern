/**
 * @fileoverview `ConfigArray` class.
 *
 * `ConfigArray` class expresses the full of a configuration. It has the entry
 * config file, base config files that were extended, loaded parsers, and loaded
 * plugins.
 *
 * `ConfigArray` class provides three properties and two methods.
 *
 * - `pluginEnvironments`
 * - `pluginProcessors`
 * - `pluginRules`
 *      The `Map` objects that contain the members of all plugins that this
 *      config array contains. Those map objects don't have mutation methods.
 *      Those keys are the member ID such as `pluginId/memberName`.
 * - `isRoot()`
 *      If `true` then this configuration has `root:true` property.
 * - `extractConfig(filePath)`
 *      Extract the final configuration for a given file. This means merging
 *      every config array element which that `criteria` property matched. The
 *      `filePath` argument must be an absolute path.
 *
 * `ConfigArrayFactory` provides the loading logic of config files.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

import { ExtractedConfig } from "./extracted-config.js";
import { IgnorePattern } from "./ignore-pattern.js";
import type { Environment } from "../../shared/types";
import type { GlobalConf } from "../../shared/types";
import type { RuleConf } from "../../shared/types";
import type { Rule } from "../../shared/types";
import type { Plugin } from "../../shared/types";
import type { Processor } from "../../shared/types";
import type { DependentParser } from "./config-dependency";
import type { DependentPlugin } from "./config-dependency";
import type { OverrideTester } from "./override-tester";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

// Define types for VSCode IntelliSense.
type ConfigArrayElement = {
    name: string;
    filePath: string;
    criteria?: InstanceType<OverrideTester> | null;
    env?: Record<string, boolean> | undefined;
    globals?: Record<string, GlobalConf> | undefined;
    ignorePattern?: IgnorePattern | undefined;
    noInlineConfig?: boolean | undefined;
    parser?: DependentParser | undefined;
    parserOptions?: object | undefined;
    plugins?: Record<string, DependentPlugin> | undefined;
    processor?: string | undefined;
    reportUnusedDisableDirectives?: boolean | undefined;
    root?: boolean | undefined;
    rules?: Record<string, RuleConf> | undefined;
    settings?: object | undefined;
    type: "config" | "ignore" | "implicit-processor";
};

type ConfigArrayInternalSlots = {
    cache: Map<string, ExtractedConfig>;
    envMap?: ReadonlyMap<string, Environment> | null;
    processorMap?: ReadonlyMap<string, Processor> | null;
    ruleMap?: ReadonlyMap<string, Rule> | null;
};

const internalSlotsMap = new WeakMap<ConfigArray, ConfigArrayInternalSlots>();

const getMatchedIndices = (elements: ConfigArrayElement[], filePath: string) => {
    const indices: number[] = [];

    for (let i = elements.length - 1; i >= 0; --i) {
        const element = elements[i];

        if (!element.criteria || (filePath && element.criteria.test(filePath))) {
            indices.push(i);
        }
    }

    return indices;
};

const isNonNullObject = (x: any) => typeof x === "object" && x !== null;

const mergeWithoutOverwrite = (target: object, source: object | undefined) => {
    if (!isNonNullObject(source)) {
        return;
    }

    for (const key of Object.keys(source)) {
        if (key === "__proto__") {
            continue;
        }

        if (isNonNullObject(target[key])) {
            mergeWithoutOverwrite(target[key], source[key]);
        } else if (target[key] === void 0) {
            if (isNonNullObject(source[key])) {
                target[key] = Array.isArray(source[key]) ? [] : {};
                mergeWithoutOverwrite(target[key], source[key]);
            } else if (source[key] !== void 0) {
                target[key] = source[key];
            }
        }
    }
};

class PluginConflictError extends Error {
    constructor(pluginId: string, plugins: {filePath: string, importerName: string}[]) {
        super(`Plugin "${pluginId}" was conflicted between ${plugins.map(p => `"${p.importerName}"`).join(" and ")}.`);
        this.messageTemplate = "plugin-conflict";
        this.messageData = { pluginId, plugins };
    }
}

const mergePlugins = (target: Record<string, DependentPlugin>, source: Record<string, DependentPlugin> | undefined) => {
    if (!isNonNullObject(source)) {
        return;
    }

    for (const key of Object.keys(source)) {
        const targetValue = target[key];
        const sourceValue = source[key];

        // Adopt the plugin which was found at first.
        if (targetValue === void 0) {
            if (sourceValue.error) {
                throw sourceValue.error;
