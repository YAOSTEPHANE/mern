import { Map, WeakMap } from 'weak-map';
import { gensync } from 'gensync';
import { isAsync, onFirstPause, waitFor } from '../gensync-utils/async';

export function assertSimpleType(value: any): string | boolean | number | null | undefined {
  if (isAsync(value)) {
    throw new Error(
      'You appear to be using an async cache handler, ' +
        'which your current version of Babel does not support.'
    );
  }
  if (value != null && typeof value !== 'string' && typeof value !== 'boolean' && typeof value !== 'number') {
    throw new Error(
      'Cache keys must be either string, boolean, number, null, or undefined.'
    );
  }
  return value;
}

export function makeStrongCache<T>(handler: (arg: T) => any): (arg: T) => Promise<any> {
  const callCacheSync = new Map<T, any[]>();
  const callCacheAsync = new Map<T, Promise<any>>();
  const futureCache = new Map<T, Promise<any>>();

  return async function cachedFunction(arg: T): Promise<any> {
    const asyncContext = await isAsync();
    const callCache = asyncContext ? callCacheAsync : callCacheSync;
    const cached = await getCachedValueOrWait(asyncContext, callCache, futureCache, arg);
    if (cached.valid) return cached.value;
    const value = await handler(arg);
    updateFunctionCache(callCache, arg, value);
    return value;
  };
}

export function makeWeakCache<T>(handler: (arg: T) => any): (arg: T) => Promise<any> {
  const callCacheSync = new WeakMap<T, any[]>();
  const callCacheAsync = new WeakMap<T, Promise<any>>();
  const futureCache = new WeakMap<T, Promise<any>>();

  return async function cachedFunction(arg: T): Promise<any> {
    const asyncContext = await isAsync();
    const callCache = asyncContext ? callCacheAsync : callCacheSync;
    const cached = await getCachedValueOrWait(asyncContext, callCache, futureCache, arg);
    if (cached.valid) return cached.value;
    const value = await handler(arg);
    updateFunctionCache(callCache, arg, value);
    return value;
  };
}

function* getCachedValue<T>(callCache: Map<T, any[]> | WeakMap<T, any[]>, arg: T): Generator<any, { valid: boolean; value: any }, any> {
  const cachedValue = callCache.get(arg);
  if (cachedValue) {
    for (const { value, valid } of cachedValue) {
      if (yield valid) return { valid: true, value };
    }
  }
  return { valid: false, value: null };
}

async function getCachedValueOrWait<T>(
  asyncContext: boolean,
  callCache: Map<T, Promise<any>> | WeakMap<T, Promise<any>>,
  futureCache: Map<T, Promise<any>> | WeakMap<T, Promise<any>>,
  arg: T
): Promise<{ valid: boolean; value: any }> {
  const cached = await getCachedValue(callCache, arg);
  if (cached.valid) {
    return cached;
  }
  if (asyncContext) {
    const cached = await getCachedValue(futureCache, arg);
    if (cached.valid) {
      const value = await waitFor(cached.value);
      return { valid: true, value };
    }
  }
  return { valid: false, value: null };
}

function updateFunctionCache<T>(
  callCache: Map<T, any[]> | WeakMap<T, any[]>,
  arg: T,
  value: any
): void {
  callCache.set(arg, [{ value, valid: () => true }]);
}

class CacheConfigurator {
  constructor(private data: any) {}

  simple(): (val: any) => void {
    return makeSimpleConfigurator(this);
  }

  mode(): 'never' | 'forever' | 'invalidate' | 'valid' {
    if (this._never) return 'never';
    if (this._forever) return 'forever';
    if (this._invalidate) return 'invalidate';
    return 'valid';
  }

  forever(): void {
    if (!this._active) {
      throw new Error(
        'Cannot change caching after evaluation has completed.'
      );
    }
    if (this._never) {
      throw new Error(
        'Caching has already been configured with .never()'
      );
    }
    this._forever = true;
    this._configured = true;
  }

  never(): void {
    if (!this._active) {
      throw new Error(
        'Cannot change caching after evaluation has completed.'
      );
    }
    if (this._forever) {
      throw new Error(
        'Caching has already been configured with .forever()'
      );
    }
    this._never = true;
    this._configured = true;
  }

  using(handler: (data: any) => any): any {
    if (!this._active) {
      throw new Error(
        'Cannot change caching after evaluation has completed.'
      );
    }
    if (this._never || this._forever) {
      throw new Error(
        'Caching has already been configured with .never or .forever()'
      );
    }
    this._configured = true;
    const key = handler(this._data);
   
