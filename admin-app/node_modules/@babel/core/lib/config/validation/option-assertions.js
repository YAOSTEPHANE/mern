"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.access = access;
exports.assertRootMode = assertRootMode;
exports.assertSourceMaps = assertSourceMaps;
exports.assertCompact = assertCompact;
exports.assertSourceType = assertSourceType;
exports.assertCallerMetadata = assertCallerMetadata;
exports.assertInputSourceMap = assertInputSourceMap;
exports.assertString = assertString;
exports.assertFunction = assertFunction;
exports.assertBoolean = assertBoolean;
exports.assertObject = assertObject;
exports.assertArray = assertArray;
exports.assertIgnoreList = assertIgnoreList;
exports.assertIgnoreItem = assertIgnoreItem;
exports.assertConfigApplicableTest = assertConfigApplicableTest;
exports.assertConfigFileSearch = assertConfigFileSearch;
exports.assertBabelrcSearch = assertBabelrcSearch;
exports.assertPluginList = assertPluginList;
exports.assertPluginItem = assertPluginItem;
exports.assertTargets = assertTargets;
exports.msg = msg;

const { isBrowsersQueryValid, TargetNames } = require("@babel/helper-compilation-targets");
const _options = require("./options.js");

function _helperCompilationTargets() {
  const data = require("@babel/helper-compilation-targets");
  _helperCompilationTargets = function () {
    return data;
  };
  return data;
}

function msg(loc) {
  switch (loc.type) {
    case "root":
      return ``;
    case "env":
      return `${msg(loc.parent)}.env["${loc.name}"]`;
    case "overrides":
      return `${msg(loc.parent)}.overrides[${loc.index}]`;
    case "option":
      return `${msg(loc.parent)}.${loc.name}`;
    case "access":
      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;
    default:
      throw new Error(`Assertion failure: Unknown type ${loc.type}`);
  }
}

function access(loc, name) {
  return {
    type: "access",
    name,
    parent: loc
  };
}

function assertRootMode(loc, value) {
  const validValues = ['root', 'upward', 'upward-optional', undefined];
  if (!validValues.includes(value)) {
    throw new Error(`${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`);
  }
  return value;
}

function assertSourceMaps(loc, value) {
  const validValues = [true, false, 'inline', 'both', undefined];
  if (!validValues.includes(value)) {
    throw new Error(`${msg(loc)} must be a boolean, "inline", "both", or undefined`);
  }
  return value;
}

function assertCompact(loc, value) {
  const validValues = [true, false, 'auto', undefined];
  if (!validValues.includes(value)) {
    throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`);
  }
  return value;
}

function assertSourceType(loc, value) {
  const validValues = ['module', 'script', 'unambiguous', undefined];
  if (!validValues.includes(value)) {
    throw new Error(`${msg(loc)} must be "module", "script", "unambiguous", or undefined`);
  }
  return value;
}

function assertCallerMetadata(loc, value) {
  if (value === undefined) {
    return value;
  }

  if (typeof value !== 'object' || value === null) {
    throw new Error(`${msg(loc)} must be an object, or undefined`);
  }

  if (value.name === undefined || typeof value.name !== 'string') {
    throw new Error(`${msg(loc)} set but does not contain "name" property string`);
  }

  for (const prop of Object.keys(value)) {
    const propLoc = access(loc, prop);
    const propValue = value[prop];
    if (propValue != null && typeof propValue !== 'boolean' && typeof propValue !== 'string' && typeof propValue !== 'number') {
      throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);
    }
  }

  return value;
}

function assertInputSourceMap(loc, value) {
  if (value === undefined) {
    return value;
  }

  if (typeof value !== 'boolean' && (!Array.isArray(value) || value.length !== 2)) {
    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);
  }

  return value;
}

function assertString(loc, value) {
  if (value === undefined) {
    return value;
  }

  if (typeof value !== 'string') {
    throw new Error(`${msg(loc)} must be a string, or undefined`);
  }

  return value;
}

function assertFunction(loc, value) {
  if (value === undefined) {
    return value;
  }

  if (typeof value !== 'function') {
    throw new Error(`${msg(loc)} must be a function, or undefined`);
  }

  return value
