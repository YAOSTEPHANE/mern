"use strict";

const data = require("@babel/helpers");
const file = require("../transformation/file/file.js");
const {
  arrayExpression,
  assignmentExpression,
  binaryExpression,
  blockStatement,
  callExpression,
  cloneNode,
  conditionalExpression,
  exportNamedDeclaration,
  exportSpecifier,
  expressionStatement,
  functionExpression,
  identifier,
  memberExpression,
  objectExpression,
  program,
  stringLiteral,
  unaryExpression,
  variableDeclaration,
  variableDeclarator
} = data.types;

const buildUmdWrapper = replacements => `
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(${replacements.AMD_ARGUMENTS}, factory);
      } else if (typeof exports === "object") {
        factory(${replacements.COMMON_ARGUMENTS});
      } else {
        factory(${replacements.BROWSER_ARGUMENTS});
      }
    })(UMD_ROOT, function (${replacements.FACTORY_PARAMETERS}) {
      ${replacements.FACTORY_BODY}
    });
  `;

const getHelperReference = name => namespace ? memberExpression(namespace, identifier(name)) : identifier(`_${name}`);

const buildHelpers = (body, namespace, allowlist) => {
  const refs = {};
  data.helpers.list.forEach(name => {
    if (allowlist && allowlist.indexOf(name) < 0) return;
    const ref = refs[name] = getHelperReference(name);
    data.helpers.ensure(name, file.default);
    const { nodes } = data.helpers.get(name, getHelperReference, ref);
    body.push(...nodes);
  });
  return refs;
};

const _default = (allowlist, outputType = "global") => {
  const build = {
    global: () => buildGlobal(allowlist),
    module: () => buildModule(allowlist),
    umd: () => buildUmd(allowlist),
    var: () => buildVar(allowlist)
  }[outputType];
  if (build) {
    const tree = build();
    return data.generator(tree).code;
  } else {
    throw new Error(`Unsupported output type ${outputType}`);
  }
};

const buildGlobal = allowlist => {
  const namespace = identifier("babelHelpers");
  const body = [];
  const container = functionExpression(null, [identifier("global")], blockStatement(body));
  const tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression("===", unaryExpression("typeof", identifier("global")), stringLiteral("undefined")), identifier("self"), identifier("global"))]))]);
  body.push(variableDeclaration("var", [variableDeclarator(namespace, assignmentExpression("=", memberExpression(identifier("global"), namespace), objectExpression([])))]));
  buildHelpers(body, namespace, allowlist);
  return tree;
};

const buildModule = allowlist => {
  const body = [];
  const refs = buildHelpers(body, null, allowlist);
  body.unshift(exportNamedDeclaration(null, Object.keys(refs).map(name => {
    return exportSpecifier(cloneNode(refs[name]), identifier(name));
  })));
  return program(body, [], "module");
};

const buildUmd = allowlist => {
  const namespace = identifier("babelHelpers");
  const body = [];
  body.push(variableDeclaration("var", [variableDeclarator(namespace, identifier("global"))]));
  buildHelpers(body, namespace, allowlist);
  return program([buildUmdWrapper({
    FACTORY_PARAMETERS: identifier("global"),
    BROWSER_ARGUMENTS: assignmentExpression("=", memberExpression(identifier("root"), namespace), objectExpression([])),
    COMMON_ARGUMENTS: identifier("exports"),
    AMD_ARGUMENTS: arrayExpression([stringLiteral("exports")]),
    FACTORY_BODY: body,
    UMD_ROOT: identifier("this")
  })]);
};

const buildVar = allowlist => {
  const namespace = identifier("babelHelpers");
  const body = [];
  body.push(variableDeclaration("var", [variableDeclarator(namespace, objectExpression([]))]));
  const tree = program(body);
  buildHelpers(body, namespace, allowlist);
  body.push(expressionStatement(namespace));
  return tree;
};

0 && 0;

//# sourceMappingURL=build-external-helpers.js.map

