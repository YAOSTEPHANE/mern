"use strict";

import {
  declare
} from "@babel/helper-plugin-utils";
import {
  template
} from "@babel/core";
import {
  wrapInterop,
  isModule,
  getModuleName,
  rewriteModuleStatementsAndPrepareHeader,
  hasExports
} from "@babel/helper-module-transforms";

const buildWrapper = template.statement(`
  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {
  })
`);

const buildAnonymousWrapper = template.statement(`
  define(["require"], function(REQUIRE) {
  })
`);

function injectWrapper(path: any, wrapper: any) {
  const {
    body,
    directives
  } = path.node;
  path.node.directives = [];
  path.node.body = [];
  const amdFactoryCall = path.pushContainer("body", wrapper)[0].get("expression");
  const amdFactoryCallArgs = amdFactoryCall.get("arguments");
  const amdFactory = amdFactoryCallArgs[amdFactoryCallArgs.length - 1].get("body");
  amdFactory.pushContainer("directives", directives);
  amdFactory.pushContainer("body", body);
}

const _default = exports.default = declare((api: any, options: any) => {
  api.assertVersion(7);
  const {
    allowTopLevelThis,
    strict,
    strictMode,
    importInterop,
    noInterop
  } = options;
  const constantReexports = (api.assumption("constantReexports")) || options.loose;
  const enumerableModuleMeta = (api.assumption("enumerableModuleMeta")) || options.loose;

  return {
    name: "transform-modules-amd",
    pre() {
      this.file.set("@babel/plugin-transform-modules-*", "amd");
    },
    visitor: {
      "CallExpression|ImportExpression": (path: any, state: any) => {
        if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
        if (path.isCallExpression() && !path.get("callee").isImport()) return;
        let {
          requireId,
          resolveId,
          rejectId
        } = state;
        if (!requireId) {
          requireId = path.scope.generateUidIdentifier("require");
          state.requireId = requireId;
        }
        if (!resolveId || !rejectId) {
          resolveId = path.scope.generateUidIdentifier("resolve");
          rejectId = path.scope.generateUidIdentifier("reject");
          state.resolveId = resolveId;
          state.rejectId = rejectId;
        }
        let result = path.scope.generateUidIdentifier("imported");
        if (!noInterop) {
          result = wrapInterop(path, result, "namespace");
        }
        path.replaceWith(
          buildDynamicImport(path.node, false, false, specifier =>
            template.expression.ast`
              new Promise((${resolveId}, ${rejectId}) =>
                ${requireId}(
                  [${specifier}],
                  imported => ${result},
                  ${rejectId}
                )
              )
            `
          )
        );
      },
      Program: {
        exit(path: any, {
          requireId
        }: any) {
          if (!isModule(path)) {
            if (requireId) {
              injectWrapper(path, buildAnonymousWrapper({
                REQUIRE: requireId
              }));
            }
            return;
          }
          const amdArgs = [];
          const importNames = [];
          if (requireId) {
            amdArgs.push("require");
            importNames.push(requireId);
          }
          let moduleName = getModuleName(this.file.opts, options);
          if (moduleName) moduleName = template.stringLiteral(moduleName);
          const {
            meta,
            headers
          } = rewriteModuleStatementsAndPrepareHeader(path, {
            enumerableModuleMeta,
            constantReexports,
            strict,
            strictMode,
            allowTopLevelThis,
            importInterop,
            noInterop,
            filename: this.file.opts.filename
          });
          if (hasExports(meta)) {
            amdArgs.push("exports");
            importNames.push(meta.exportName);
          }
          for (const [source, metadata] of meta.source) {
            amdArgs.push(source);
            importNames.push(metadata.name);
            if (!isSideEffectImport(metadata)) {
              const interop = wrapInterop(path, path.scope.generateUidIdentifier(metadata.name), metadata.interop);
              if (interop) {
                const header = template.expressionStatement(template.assignmentExpression("=", path.scope.generateUidIdentifier(metadata.name), interop));
                header.loc = metadata.loc;
                headers.push(header);
              }
            }
            headers.push(...buildNamespaceInitStatements(meta, metadata, constantReexports));
          }
          ensureStatementsHoisted(headers);
          path.unshiftContainer("body", headers);
          injectWrapper(path, buildWrapper({
            MODULE_NAME: moduleName,
            AMD_ARGUMENTS: template.arrayExpression(amdArgs),
            IMPORT_NAMES: importNames
          }));
        }
      }
    }
  };
});
