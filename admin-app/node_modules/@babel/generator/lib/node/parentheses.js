"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrowFunctionExpression = exports.AssignmentExpression = exports.Binary = exports.BinaryExpression = exports.ClassExpression = exports.ConditionalExpression = exports.DoExpression = exports.FunctionExpression = exports.FunctionTypeAnnotation = exports.Identifier = exports.LogicalExpression = exports.NullableTypeAnnotation = exports.ObjectExpression = exports.OptionalIndexedAccessType = exports.OptionalMemberExpression = exports.SequenceExpression = exports.TSTypeAssertion = exports.TSSatisfiesExpression = exports.TSAsExpression = exports.TSInferType = exports.TSInstantiationExpression = exports.TSIntersectionType = exports.TSUnionType = exports.UnaryLike = exports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = exports.UpdateExpression = exports.AwaitExpression = exports.YieldExpression = void 0;
const t = require("@babel/types");
const {
  isArrayTypeAnnotation,
  isArrowFunctionExpression,
  isBinaryExpression,
  isCallExpression,
  isExportDeclaration,
  isForOfStatement,
  isIndexedAccessType,
  isMemberExpression,
  isObjectPattern,
  isOptionalMemberExpression,
  isYieldExpression,
} = t;
const precedence = new Map([
  ["||", 0],
  ["??", 0],
  ["|>", 0],
  ["&&", 1],
  ["|", 2],
  ["^", 3],
  ["&", 4],
  ["==", 5],
  ["===", 5],
  ["!=", 5],
  ["!==", 5],
  ["<", 6],
  [">", 6],
  ["<=", 6],
  [">=", 6],
  ["in", 6],
  ["instanceof", 6],
  [">>", 7],
  ["<<", 7],
  [">>>", 7],
  ["+", 8],
  ["-", 8],
  ["*", 9],
  ["/", 9],
  ["%", 9],
  ["**", 10],
]);
function isTSTypeExpression(nodeType) {
  return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
}
const isClassExtendsClause = (node, parent) => {
  const parentType = parent.type;
  return (
    (parentType === "ClassDeclaration" || parentType === "ClassExpression") &&
    parent.superClass === node
  );
};
const hasPostfixPart = (node, parent) => {
  const parentType = parent.type;
  return (
    (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") &&
    parent.object === node ||
    (parentType === "CallExpression" ||
      parentType === "OptionalCallExpression" ||
      parentType === "NewExpression") &&
      parent.callee === node ||
    parentType === "TaggedTemplateExpression" && parent.tag === node ||
    parentType === "TSNonNullExpression"
  );
};
function NullableTypeAnnotation(node, parent) {
  return isArrayTypeAnnotation(parent);
}
function FunctionTypeAnnotation(node, parent, printStack) {
  if (printStack.length < 3) return false;
  const parentType = parent.type;
  return (
    parentType === "UnionTypeAnnotation" ||
    parentType === "IntersectionTypeAnnotation" ||
    parentType === "ArrayTypeAnnotation" ||
    (parentType === "TypeAnnotation" && isArrowFunctionExpression(printStack[printStack.length - 3]))
  );
}
function UpdateExpression(node, parent) {
  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
}
function ObjectExpression(node, parent, printStack) {
  return isFirstInContext(printStack, 1 | 2);
}
function DoExpression(node, parent, printStack) {
  return !node.async && isFirstInContext(printStack, 1);
}
function Binary(node, parent) {
  const parentType = parent.type;
  if (node.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
    return parent.left === node;
  }
  if (isClassExtendsClause(node, parent)) {
    return true;
  }
  if (
    hasPostfixPart(node, parent) ||
    parentType === "UnaryExpression" ||
    parentType === "SpreadElement" ||
    parentType === "AwaitExpression"
  ) {
    return true;
  }
  if (
    parentType === "BinaryExpression" ||
    parentType === "LogicalExpression"
  ) {
    const parentPos = precedence.get(parent.operator);
    const nodePos = precedence.get(node.operator);
    if (parentPos === nodePos && parent.right === node && parentType !== "LogicalExpression" || parentPos > nodePos) {
      return true;
    }
  }
  return undefined;
}
function UnionTypeAnnotation(node, parent) {
  const parentType = parent.type;
  return (
    parentType === "ArrayTypeAnnotation" ||
    parentType === "NullableTypeAnnotation" ||
    parentType === "IntersectionTypeAnnotation" ||
    parentType === "UnionTypeAnnotation"
  );
}
function OptionalIndexedAccessType(node, parent) {
  return isIndexedAccessType(parent) && parent.objectType === node;
}
function TSAsExpression() {
  return
