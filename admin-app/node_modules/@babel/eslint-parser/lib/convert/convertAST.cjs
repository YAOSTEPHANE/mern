import { ESLintVersion } from "../utils/eslint-version";

const ESLINT_VERSION = new ESLintVersion();

function* it(children: any) {
  if (Array.isArray(children)) {
    yield* children.flatMap(it);
  } else {
    yield children;
  }
}

function convertNodes(node: any, visitorKeys: any) {
  if (!node) return;
  const { type } = node;
  if (!type) return;
  const keys = visitorKeys[type];
  if (!keys) return;
  for (const key of keys) {
    for (const child of it(node[key])) {
      if (child && typeof child === "object") {
        convertNode(child, visitorKeys);
      }
    }
  }
}

function convertNode(node: any, visitorKeys: any) {
  if (!node) return;
  const { type } = node;
  if (!type) return;
  const keys = visitorKeys[type];
  if (!keys) return;
  for (const key of keys) {
    if (node[key] && typeof node[key] === "object") {
      convertNode(node[key], visitorKeys);
    }
  }
  visitorKeys[type].forEach((key: string) => {
    if (node[key] && typeof node[key] === "object") {
      const convertFn = convertNodesVisitor[key];
      if (convertFn) {
        convertFn(node);
      }
    }
  });
}

const convertNodesVisitor = {
  enter(node: any) {
    if (node.innerComments) {
      delete node.innerComments;
    }
    if (node.trailingComments) {
      delete node.trailingComments;
    }
    if (node.leadingComments) {
      delete node.leadingComments;
    }
  },
  exit(node: any) {
    if (node.extra) {
      delete node.extra;
    }
    if (node.loc && node.loc.identifierName) {
      delete node.loc.identifierName;
    }
    if (node.type === "TypeParameter") {
      node.type = "Identifier";
      node.typeAnnotation = node.bound;
      delete node.bound;
    }
    if (node.type === "QualifiedTypeIdentifier") {
      delete node.id;
    }
    if (node.type === "ObjectTypeProperty") {
      convertObjectTypeProperty(node);
    }
    if (node.type === "ObjectTypeIndexer") {
      convertObjectTypeIndexer(node);
    }
    if (node.type === "FunctionTypeParam") {
      convertFunctionTypeParam(node);
    }
    if (node.type === "ImportDeclaration") {
      convertImportDeclaration(node);
    }
    if (node.type === "TemplateLiteral") {
      convertQuasis(node);
    }
  }
};

function convertQuasis(node: any) {
  for (let i = 0; i < node.quasis.length; i++) {
    const q = node.quasis[i];
    q.range[0] -= 1;
    if (q.tail) {
      q.range[1] += 1;
    } else {
      q.range[1] += 2;
    }
    q.loc.start.column -= 1;
    if (q.tail) {
      q.loc.end.column += 1;
    } else {
      q.loc.end.column += 2;
    }
    if (ESLINT_VERSION.ge(8)) {
      q.start -= 1;
      if (q.tail) {
        q.end += 1;
      } else {
        q.end += 2;
      }
    }
  }
}

function convertObjectTypeProperty(node: any) {
  delete node.key;
}

function convertObjectTypeIndexer(node: any) {
  delete node.id;
}

function convertFunctionTypeParam(node: any) {
  delete node.name;
}

function convertImportDeclaration(node: any) {
  delete node.isType;
}

function convertProgramNode(ast: any) {
  ast.type = "Program";
  ast.sourceType = ast.program.sourceType;
  ast.body = ast.program.body;
  delete ast.program;
  delete ast.errors;
  if (ast.comments.length) {
   
