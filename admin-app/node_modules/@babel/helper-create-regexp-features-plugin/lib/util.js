"use strict";

import { hasFeature } from "./features.js";

/**
 * Generates options for the `regexpu` function based on the given pattern and transformation flags.
 * @param pattern - The regular expression pattern to analyze.
 * @param toTransform - The transformation flags to apply.
 * @returns The generated options for the `regexpu` function.
 */
export function generateRegexpuOptions(pattern, toTransform) {
  const feat = (name, ok = "transform") =>
    hasFeature(toTransform, Object.values(FEATURES)[name]) ? ok : false;

  const FEATURES = {
    duplicateNamedCaptureGroups: "duplicateNamedCaptureGroups",
    unicodeFlag: "unicodeFlag",
    unicodeSetsFlag: "unicodeSetsFlag",
    dotAllFlag: "dotAllFlag",
    unicodePropertyEscapes: "unicodePropertyEscapes",
    namedCaptureGroups: "namedCaptureGroups",
    modifiers: "modifiers",
  };

  const regex = /\(\?<([^>]+)>/g;
  const seen = new Set();

  const featDuplicateNamedGroups = () =>
    feat("duplicateNamedCaptureGroups")
      ? regex.test(pattern) &&
          [...pattern.matchAll(regex)].some(
            (match) => seen.has(match[1]) || seen.add(match[1])
          )
      : false;

  return {
    unicodeFlag: feat("unicodeFlag", true),
    unicodeSetsFlag: feat("unicodeSetsFlag", "parse") || false,
    dotAllFlag: feat("dotAllFlag", true),
    unicodePropertyEscapes: feat("unicodePropertyEscapes", true),
    namedGroups: feat("namedCaptureGroups", true) || featDuplicateNamedGroups(),
    onNamedGroup: () => {},
    modifiers: feat("modifiers", true),
  };
}

/**
 * Checks if the given node can be skipped by the `regexpu` function based on the given options.
 * @param node - The node to check.
 * @param options - The options to use for checking.
 * @returns `true` if the node can be skipped, `false` otherwise.
 */
export function canSkipRegexpu(node, options) {
  const { flags, pattern } = node;

  if (flags.includes("v")) {
    if (options.unicodeSetsFlag === "transform") return false;
  }

  if (flags.includes("u")) {
    if (options.unicodeFlag === "transform") return false;
    if (
      options.unicodePropertyEscapes === "transform" &&
      /\\[pP]{/.test(pattern)
    ) {
      return false;
    }
  }

  if (flags.includes("s")) {
    if (options.dotAll
