"use strict";

import * as t from "@babel/types";
import { file as fileHelper, template as templateHelper } from "@babel/core";
import { environmentVisitor as envVisitor, skipAllButComputedKey as skipComputedKey } from "@babel/helper-environment-visitor";
import { memberExpressionToFunctions as memberExpToFunctions } from "@babel/helper-member-expression-to-functions";
import { optimiseCallExpression as optimiseCallExp } from "@babel/helper-optimise-call-expression";

const {
  assignmentExpression,
  booleanLiteral,
  callExpression,
  cloneNode,
  identifier,
  memberExpression,
  sequenceExpression,
  stringLiteral,
  thisExpression
} = t;

export { environmentVisitor as default, skipAllButComputedKey };

function getPrototypeOfExpression(objectRef: t.Expression, isStatic: boolean, file: fileHelper.File, isPrivateMethod: boolean) {
  objectRef = cloneNode(objectRef);
  const targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
  return callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
}

const visitor: t.Visitor = t.traverse.visitors.merge([envVisitor, {
  Super(path: t.Path, state: any) {
    const { node, parentPath } = path;
    if (!parentPath.isMemberExpression({ object: node })) return;
    state.handle(parentPath);
  }
}]);

const unshadowSuperBindingVisitor: t.Visitor = t.traverse.visitors.merge([envVisitor, {
  Scopable(path: t.Path, { refName }: { refName: string }) {
    const binding = path.scope.getOwnBinding(refName);
    if (binding && binding.identifier.name === refName) {
      path.scope.rename(refName);
    }
  }
}]);

interface SuperMember {
  node: {
    computed: boolean;
    property: t.Expression | t.StringLiteral;
  };
}

const specHandlers: { [key: string]: (this: any, superMember: SuperMember) => t.Node } = {
  memoise(superMember: SuperMember, count: number) {
    const { scope, node } = superMember;
    const { computed, property } = node;
    if (!computed) {
      return;
    }
    const memo = scope.maybeGenerateMemoised(property);
    if (!memo) {
      return;
    }
    this.memoiser.set(property, memo, count);
  },
  prop(superMember: SuperMember) {
    const { computed, property } = superMember.node;
    if (this.memoiser.has(property)) {
      return cloneNode(this.memoiser.get(property));
    }
    if (computed) {
      return cloneNode(property);
    }
    return stringLiteral(property.name);
  },
  get(superMember: SuperMember) {
    return this._get(superMember, this._getThisRefs());
  },
  _get(superMember: SuperMember, thisRefs: { memo?: t.AssignmentExpression; this: t.Expression }) {
    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return callExpression(this.file.addHelper("get"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);
  },
  _getThisRefs() {
    if (!this.isDerivedConstructor) {
      return {
        this: thisExpression()
      };
    }
    const thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
    return {
      memo: assignmentExpression("=", thisRef, thisExpression()),
      this: cloneNode(thisRef)
    };
  },
  set(superMember: SuperMember, value: t.Node) {
    const thisRefs = this._getThisRefs();
    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
    return callExpression(this.file.addHelper("set"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs.this, booleanLiteral(superMember.node.isInStrictMode())]);
  },
  destructureSet(superMember: SuperMember) {
    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);
  },
  call(superMember: SuperMember, args: t.Node[]) {
    const thisRefs = this._getThisRefs();
    return optimiseCallExp(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, false);
  },
  optionalCall(superMember: SuperMember, args: t.Node[]) {
    const thisRefs = this._getThisRefs();
    return optimiseCallExp(this._get(superMember, thisRefs), cloneNode(thisRefs.this), args, true);
  },
  delete(superMember: SuperMember) {
    if (superMember.node.computed) {
      return sequenceExpression([callExpression(this.file.addHelper("toPropertyKey"), [cloneNode(superMember.node.property)]), templateHelper.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]);
    } else
