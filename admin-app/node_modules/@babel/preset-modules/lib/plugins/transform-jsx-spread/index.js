"use strict";

import { types as t } from "@babel/core";
import { helper as helper$1 } from "@babel/helper-function-name";
import { helper as helper$2 } from "@babel/helper-plugin-utils";
import { helper as helper$3 } from "@babel/helper-module-imports";

const _interopRequireDefault = require("@babel/helper-plugin-utils").default.interopRequireDefault;

const _helperPluginUtils = require("@babel/helper-plugin-utils");

const _helperFunctionName = require("@babel/helper-function-name");

const _helperModuleImports = require("@babel/helper-module-imports");

const _default = (api) => {
  const {
    types: t$1
  } = api;
  const transformJSXSpread = (path, state) => {
    const useSpread = state.opts.useSpread === true;
    const hasSpread = path.node.attributes.some(attr => t$1.isJSXSpreadAttribute(attr)); // ignore JSX Elements without spread or with lone spread:

    if (!hasSpread || path.node.attributes.length === 1) return;

    if (useSpread) {
      path.node.attributes = [t$1.jsxSpreadAttribute(t$1.objectExpression(path.node.attributes.map(convertAttributeSpread)))];
    } else {
      path.node.attributes = [t$1.jsxSpreadAttribute(convertAttributesAssign(path.node.attributes))];
    }
  };

  const convertAttributesAssign = attributes => {
    const args = [t$1.objectExpression([])];

    for (let i = 0, current; i < attributes.length; i++) {
      const node = attributes[i];

      if (t$1.isJSXSpreadAttribute(node)) {
        // the first attribute is a spread, avoid copying all other attributes onto it
        if (i === 0) {
          args.push(node.argument);
          continue;
        }

        current = null;
      } else {
        const name = getAttributeName(node);
        const value = getAttributeValue(node);

        if (!current) {
          current = t$1.objectExpression([]);
          args.push(current);
        }

        current.properties.push(t$1.objectProperty(name, value));
      }
    }

    return t$1.callExpression(t$1.memberExpression(t$1.identifier("Object"), t$1.identifier("assign")), args);
  }; // Converts a JSXAttribute to the equivalent ObjectExpression property


  const convertAttributeSpread = node => {
    if (t$1.isJSXSpreadAttribute(node)) {
      return t$1.spreadElement(node.argument);
    }

    const name = getAttributeName(node);
    const value = getAttributeValue(node);
    return t$1.inherits(t$1.objectProperty(name, value), node);
  }; // Convert a JSX attribute name to an Object expression property name


  const getAttributeName = node => {
    if (t$1.isJSXNamespacedName(node.name)) {
      return t$1.stringLiteral(node.name.namespace.name + ":" + node.name.name.name);
    }

    if (t$1.isJSXIdentifier(node.name)) {
      return t$1.identifier(node.name.name);
    }

    return t$1.stringLiteral(node.name.name);
  }; // Convert a JSX attribute value to a JavaScript expression value


  const getAttributeValue = node => {
    let value = node.value || t$1.booleanLiteral(true);

    if (t$1.isJSXExpressionContainer(value)) {
      value = value.expression;
    } else if (t$1.isStringLiteral(value)) {
      value.value = value.value.replace(/\n\s+/g, " "); // "raw" JSXText should not be used from a StringLiteral because it needs to be escaped.

      if (value.extra && value.extra.raw) {
        delete value.extra.raw;
      }
    }

    return value;
  };

  const {
    file
  } = state;
  const {
    opts: {
      useSpread,
      runtime
    }
  } = state;
  const helperName = helper$1(file.scope.generateUidIdentifier("transformJSXSpread"));
  const runtimeRequire = helper$3(file, "@babel/runtime", {
    name: "helpers",
    source: runtime
  }).default;
  const runtimeTransformJSXSpread = helper$3(file, runtimeRequire, {
    name: "transformJSXSpread",
    source: runtime
  }).default;

  if (!file.hasPlugin("transform-runtime")) {
    file.addHelpter(runtimeRequire);
  }

  file.set("transformJSXSpread", runtimeTransformJSXSpread);
  const transformJSXSpread
