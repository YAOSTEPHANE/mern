import { default as _typeof } from './typeof.js';

function createAddInitializerMethod(executionContext: any, propertyKey: PropertyKey) {
  return function (initializer: () => void) {
    if (executionContext.v) {
      throw new Error('attempted to call addInitializer after decoration was finished');
    }
    assertCallable(initializer, 'An initializer');
    executionContext.push(initializer);
  };
}

function memberDec(
  decorator: (target: any, propertyKey: PropertyKey, descriptor: PropertyDescriptor) => void,
  propertyKey: PropertyKey,
  propertyDescriptor: PropertyDescriptor,
  target: any,
  kind: number,
  staticFlag: boolean,
  privateFlag: boolean
): void {
  const propertyName = privateFlag ? '#' + propertyKey : propertyKey;
  const property: PropertyDescriptor = {
    kind,
    name: propertyName,
    static: staticFlag,
    private: privateFlag,
  };

  if (kind !== 0) {
    property.addInitializer = createAddInitializerMethod(target, propertyName);
  }

  if (kind === 0) {
    if (privateFlag) {
      property.get = propertyDescriptor.get;
      property.set = propertyDescriptor.set;
    } else {
      property.value = propertyDescriptor.value;
    }
  } else if (kind === 1) {
    property.get = propertyDescriptor.get;
    property.set = propertyDescriptor.set;
  } else if (kind === 2) {
    property.value = propertyDescriptor.value;
  } else if (kind === 3) {
    property.get = propertyDescriptor.get;
  } else if (kind === 4) {
    property.set = propertyDescriptor.set;
  }

  decorator(target, propertyName, property);
}

function assertCallable(fn: any, message: string): void {
  if (typeof fn !== 'function') {
    throw new TypeError(message + ' must be a function');
  }
}

function applyMemberDec(
  decorators: Function[],
  target: any,
  propertyKey: PropertyKey,
  descriptor: PropertyDescriptor,
  kind: number,
  staticFlag: boolean,
  privateFlag: boolean
): void {
  const originalDescriptor = descriptor || Object.getOwnPropertyDescriptor(target, propertyKey);
  const decoratorResults: Function[] = [];

  for (const decorator of decorators) {
    const result = memberDec(decorator, propertyKey, originalDescriptor, target, kind, staticFlag, privateFlag);
    decoratorResults.push(result);
  }

  if (kind !== 0) {
    if (decoratorResults.length > 1) {
      const initFunctions = decoratorResults.filter((fn): fn is Function => typeof fn === 'function');
      descriptor.init = function (...args: any[]) {
        for (const fn of initFunctions) {
          fn.apply(this, args);
        }
      };
    } else if (decoratorResults.length === 1) {
      const fn = decoratorResults[0];
      descriptor.init = fn;
    }
  } else {
    if (descriptor) {
      if (privateFlag) {
        descriptor.get = decoratorResults[0].get;
        descriptor.set = decoratorResults[0].set;
      } else {
        descriptor.value = decoratorResults[0];
      }
    } else {
      Object.defineProperty(target, propertyKey, {
        get: decoratorResults[0].get,
        set: decoratorResults[0].set,
      });
    }
  }
}

function pushInitializers(target: any, initializers: Function[]): void {
  if (initializers) {
    initializers.push(function (instance: any) {
      for (const initializer of initializers) {
        initializer.call(instance);
      }
      return instance;
    });
  }
}

function applyDecs2203Factory() {
  const classDecs: Function[] = [];
  const propertyDecs: Function[] = [];

  return function (target: any, propertyKey: PropertyKey, descriptor: PropertyDescriptor) {
    if (propertyKey) {
      if (typeof propertyKey === 'string') {
        const kind = descriptor ? descriptor.value ? 2 : descriptor.get ? 1 : 0 : 0;
        const staticFlag = kind !== 0 && descriptor ? descriptor.configurable ? false : descriptor.writable : false;
        const privateFlag = kind !== 0 && /^#/.test(propertyKey);
        applyMemberDec(classDecs, target.constructor, propertyKey, descriptor, kind, staticFlag, privateFlag);
      } else {
        for (const key of propertyKey) {
          const kind = descriptor ? descriptor.value ? 2 : descriptor.get ? 1 : 0 : 0;
          const staticFlag = kind !== 0 && descriptor ? descriptor.configurable ? false : descriptor.writable : false;
          applyMemberDec(classDecs, target, key, descriptor, kind, staticFlag, false);
        }
      }
    } else {
      for (const key of Object.getOwnPropertyNames(target)) {
        const descriptor = Object.getOwnPropertyDescriptor(target, key);
        const kind = descriptor ? descriptor.value ? 2 : descriptor.get ? 1 : 0 : 0;
        const staticFlag = kind !== 0 && descriptor ? descriptor.configurable ? false : descriptor.writable : false;
        applyMemberDec(propertyDecs, target, key, descriptor, kind, staticFlag, false);
      }
    }

    pushInitializers(target, classDecs);
  };
}

let applyDecs2203Impl: any;

function applyDecs2203(target: any, propertyKey?: PropertyKey, descriptor?: Property
