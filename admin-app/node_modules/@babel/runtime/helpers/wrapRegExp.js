// Import required modules
const setPrototypeOf = require("./setPrototypeOf.js");
const inherits = require("./inherits.js");

// Create a new RegExp constructor
function _wrapRegExp(pattern, flags, groupNames) {
  // Create a WeakMap to store the groupNames for each RegExp instance
  const groupNamesMap = new WeakMap();

  // Create a new constructor for the BabelRegExp
  function BabelRegExp(pattern, flags) {
    const regex = new RegExp(pattern, flags);
    groupNamesMap.set(regex, groupNames || groupNamesMap.get(pattern));
    setPrototypeOf(regex, BabelRegExp.prototype);
    return regex;
  }

  // Inherit from the built-in RegExp constructor
  inherits(BabelRegExp, RegExp);

  // Override the exec method to add groupNames to the result
  BabelRegExp.prototype.exec = function (str) {
    const result = RegExp.prototype.exec.call(this, str);
    if (result) {
      result.groups = buildGroups(result, this);
      const indices = result.indices;
      indices && (indices.groups = buildGroups(indices, this));
    }
    return result;
  };

  // Override the Symbol.replace method to replace groupNames in the replacement string
  BabelRegExp.prototype[Symbol.replace] = function (str, replaceValue) {
    if (typeof replaceValue === "string") {
      const groupNamesObj = groupNamesMap.get(this);
      return RegExp.prototype[Symbol.replace].call(
        this,
        str,
        replaceValue.replace(/\$<([^>]+)>/g, (_, name) => {
          const group = groupNamesObj[name];
          return "$" + (Array.isArray(group) ? group.join("$") : group);
        })
      );
    }
    if (typeof replaceValue === "function") {
      const self = this;
      return RegExp.prototype[Symbol.replace].call(
        this,
        str,
        function () {
          const args = [...arguments];
          const groupNamesObj = groupNamesMap.get(self);
          if (args.length > 1 && typeof args[args.length - 1] !== "object") {
            args.push(buildGroups(args, self));
          }
          return replaceValue.apply(this, args);
        }
      );
    }
    return RegExp.prototype[Symbol.replace].call(this, str, replaceValue);
  };

  // Helper function to build the groupNames object
  function buildGroups(result, regex) {
    const groupNamesObj = groupNamesMap.get(regex);
    return Object.keys(groupNamesObj).reduce((groups, name) => {
      const group = groupNamesObj[name];
      if (typeof group === "
