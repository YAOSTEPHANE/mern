import { Type } from "./typeof";

type MemberDecorator = (
  target: object,
  propertyKey: string | symbol,
  descriptor: PropertyDescriptor
) => PropertyDescriptor | void;

type ClassDecorator = (
  target: Function,
  propertyKey: string | symbol,
  descriptor: PropertyDescriptor
) => TypedPropertyDescriptor<any> | void;

function assertCallable(target: any, message: string) {
  if (typeof target !== "function") {
    throw new TypeError(message + " must be a function");
  }
}

function assertValidReturnValue(
  type: number,
  target: any
) {
  if (type === 1) {
    if (typeof target !== "object" || target === null) {
      throw new TypeError(
        "accessor decorators must return an object with get, set, or init properties or void 0"
      );
    }
    if (target.get !== undefined) {
      assertCallable(target.get, "accessor.get");
    }
    if (target.set !== undefined) {
      assertCallable(target.set, "accessor.set");
    }
    if (target.init !== undefined) {
      assertCallable(target.init, "accessor.init");
    }
  } else if (typeof target !== "function") {
    throw new TypeError(
      (type === 0 ? "field" : type === 10 ? "class" : "method") +
        " decorators must return a function or void 0"
    );
  }
}

function createAddInitializerMethod(
  addInitializers: Array<() => void>,
  property: { v: boolean }
) {
  return function (initializer: () => void) {
    if (property.v) {
      throw new Error(
        "attempted to call addInitializer after decoration was finished"
      );
    }
    assertCallable(initializer, "An initializer");
    addInitializers.push(initializer);
  };
}

function memberDec(
  decorator: MemberDecorator,
  target: object,
  propertyKey: string | symbol,
  descriptor: PropertyDescriptor,
  propertyType: number,
  isStatic: boolean,
  isPrivate: boolean
) {
  const property: {
    kind: string;
    name: string;
    static: boolean;
    private: boolean;
    addInitializer?: (initializer: () => void) => void;
  } = {
    kind: "",
    name: propertyKey.toString(),
    static: isStatic,
    private: isPrivate,
  };

  switch (propertyType) {
    case 1:
      property.kind = "accessor";
      break;
    case 2:
      property.kind = "method";
      break;
    case 3:
      property.kind = "getter";
      break;
    case 4:
      property.kind = "setter";
      break;
    default:
      property.kind = "field";
  }

  const propertyWithInitializer: {
    v: boolean;
    kind: string;
    name: string;
    static: boolean;
    private: boolean;
    get?: () => any;
    set?: (value: any) => void;
    addInitializer?: (initializer: () => void) => void;
  } = {
    ...property,
    v: false,
  };

  if (propertyType !== 0) {
    propertyWithInitializer.addInitializer = createAddInitializerMethod(
      descriptor.initializer ? [descriptor.initializer] : [],
      propertyWithInitializer
    );
  }

  if (propertyType === 0) {
    if (isPrivate) {
      Object.defineProperty(target, "#" + propertyKey, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: descriptor.value,
      });
      property.name = "#" + propertyKey;
    } else {
      property.get = descriptor.get;
      property.set = descriptor.set;
    }
  } else {
    if (propertyType === 1) {
      if (isPrivate) {
        Object.defineProperty(target, "#" + propertyKey, {
          configurable: true,
          enumerable: false,
          writable: true,
          value: {
            get: descriptor.get,
            set: descriptor.set,
          },
        });
        property.name = "#" + propertyKey;
      } else {
        property.get = descriptor.get;
        property.set = descriptor.set;
      }
    } else if (propertyType === 2) {
      property.value = descriptor.value;
    } else if (propertyType === 3) {
      property.get = descriptor.get;
    } else if (propertyType === 4) {
      property.set = descriptor.set;
    }

    if (descriptor.initializer) {
      propertyWithInitializer.addInitializer!(
        descriptor.initializer
      );
    }
  }

  return decorator(target, propertyKey, propertyWithInitializer);
}

function applyMemberDec(
  decorators: Array<MemberDecorator | ClassDecorator>,
  target: object | Function,
  propertyKey: string | symbol,
  descriptor: PropertyDescriptor,
  propertyType: number,
  isStatic: boolean,
  isPrivate: boolean
) {
  const originalDescriptor = descriptor;
  let resultDescriptor = descriptor;

  for (const decorator of decorators) {
    if (typeof decorator === "function") {
      resultDescriptor = memberDec(
        decorator,
        target,
        propertyKey,
        resultDescriptor,
        propertyType,
        isStatic,
        isPrivate
      );
    } else {
      resultDescriptor = decorator(

