function* _asyncIterator(r) {
  const symbols = [Symbol.asyncIterator, Symbol.iterator];
  for (let i = 0; i < symbols.length; i++) {
    const symbol = symbols[i];
    if (symbol && null != r[symbol]) {
      return r[symbol].call(r);
    }
  }
  throw new TypeError("Object is not async iterable");
}

function AsyncFromSyncIterator(r) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) {
      return Promise.reject(new TypeError(r + " is not an object."));
    }
    const { done, value } = r;
    return Promise.resolve(value).then(val => ({
      value: val,
      done
    }));
  }

  return {
    next: async function next(...args) {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, args));
    },
    return: async function _return(r, ...args) {
      const n = this.s["return"];
      if (n) {
        return AsyncFromSyncIteratorContinuation(n.apply(this.s, args));
      }
      return Promise.resolve({
        value: r,
        done: true
      });
    },
    throw: async function _throw(r, ...args) {
      const n = this.s["return"];
      if (n) {
        return AsyncFromSyncIteratorContinuation(n.apply(this.s, args));
      }
      return Promise.reject(r);
    }
  };
}

module.exports = _asyncIterator;
module.exports.__esModule = true;
module.exports["default"] = _asyncIterator;
