"use strict";

import type { NodePath } from "@babel/core";
import type { Comment } from "@babel/types";
import { addComment as _addComment, addComments as _addComments } from "@babel/types";

const { isValidType, isString } = _t;

function shareCommentsWithSiblings(this: NodePath): void {
  if (typeof this.key !== "string") return;
  const node = this.node;
  if (!node) return;
  const trailing = node.trailingComments;
  const leading = node.leadingComments;
  if (!trailing && !leading) return;
  const prev = this.getSibling(this.key - 1);
  const next = this.getSibling(this.key + 1);
  const hasPrev = Boolean(prev.node);
  const hasNext = Boolean(next.node);
  if (hasPrev) {
    if (leading) {
      prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
    }
    if (trailing && !hasNext) prev.addComments("trailing", trailing);
  }
  if (hasNext) {
    if (trailing) {
      next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
    }
    if (leading && !hasPrev) next.addComments("leading", leading);
  }
}

function removeIfExisting(list: Comment[], toRemove: Comment[]): Comment[] {
  if (!toRemove.length) return list;
  const set = new Set(toRemove);
  return list.filter((el) => !set.has(el));
}

function addComment(type: "CommentLine" | "CommentBlock", content: string, line?: boolean): void {
  if (!isValidType(type)) {
    throw new Error(`Invalid type: ${type}`);
  }
  if (!isString(content)) {
    throw new Error(`Invalid content: ${content}`);
  }
  _addComment(this.node, type, content, line);

