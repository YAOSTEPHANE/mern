"use strict";

const virtualTypes = require("./lib/virtual-types.js");
const { default: debug } = require("debug");
const { default: t } = require("@babel/types");
const cache = require("../cache.js");
const { default: NodePath_ancestry } = require("./ancestry.js");
const { default: NodePath_inference } = require("./inference/index.js");
const { default: NodePath_replacement } = require("./replacement.js");
const { default: NodePath_evaluation } = require("./evaluation.js");
const { default: NodePath_conversion } = require("./conversion.js");
const { default: NodePath_introspection } = require("./introspection.js");
const { default: NodePath_context } = require("./context.js");
const { default: NodePath_removal } = require("./removal.js");
const { default: NodePath_modification } = require("./modification.js");
const { default: NodePath_family } = require("./family.js");
const { default: NodePath_comments } = require("./comments.js");
const { validate } = t;
const debug$1 = debug("babel");
const REMOVED = exports.REMOVED = 1 << 0;
const SHOULD_STOP = exports.SHOULD_STOP = 1 << 1;
const SHOULD_SKIP = exports.SHOULD_SKIP = 1 << 2;

class NodePath {
  constructor(hub, parent) {
    this.contexts = [];
    this.state = null;
    this.opts = null;
    this._traverseFlags = 0;
    this.skipKeys = null;
    this.parentPath = null;
    this.container = null;
    this.listKey = null;
    this.key = null;
    this.node = null;
    this.type = null;
    this.parent = parent;
    this.hub = hub;
    this.data = null;
    this.context = null;
    this.scope = null;

    return this;
  }

  // ... rest of the code
}

Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);

{
  NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
}

for (const type of t.TYPES) {
  const typeKey = `is${type}`;
  const fn = t[typeKey];
  NodePath.prototype[typeKey] = function (opts) {
    return fn(this.node, opts);
  };
  NodePath.prototype[`assert${type}`] = function (opts) {
    if (!fn(this.node, opts)) {
      throw new TypeError(`Expected node path of type ${type}`);
    }
  };
}

Object.assign(NodePath.prototype, NodePath_virtual_types_validator);

for (const type of Object.keys(virtualTypes)) {
  if (type[0] === "_") continue;
  if (!t.TYPES.includes(type)) t.TYPES.push(type);
}

const _default = exports.default = NodePath;

//# sourceMappingURL=index.js.map
