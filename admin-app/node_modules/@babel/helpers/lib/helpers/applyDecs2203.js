"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = applyDecs2203;

function applyDecs2203Factory() {
  function createAddInitializerMethod(initializers: any[], decoratorFinishedRef: { v: boolean }) {
    return function addInitializer(initializer: any) {
      assertNotFinished(decoratorFinishedRef, "addInitializer");
      assertCallable(initializer, "An initializer");
      initializers.push(initializer);
    };
  }

  function memberDec(
    dec: any,
    name: string | symbol,
    desc: PropertyDescriptor,
    initializers: any[],
    kind: number,
    isStatic: boolean,
    isPrivate: boolean,
    value?: any
  ) {
    switch (kind) {
      case 1:
        return dec(value, { kind: "accessor", name: isPrivate ? "#" + name : name, static: isStatic, private: isPrivate });
      case 2:
        return dec(value, { kind: "method", name: isPrivate ? "#" + name : name, static: isStatic, private: isPrivate });
      case 3:
        return dec(value, { kind: "getter", name: isPrivate ? "#" + name : name, static: isStatic, private: isPrivate });
      case 4:
        return dec(value, { kind: "setter", name: isPrivate ? "#" + name : name, static: isStatic, private: isPrivate });
      default:
        return dec(value, { kind: "field", name: isPrivate ? "#" + name : name, static: isStatic, private: isPrivate });
    }
  }

  function assertNotFinished(decoratorFinishedRef: { v: boolean }, fnName: string) {
    if (decoratorFinishedRef.v) {
      throw new Error(`attempted to call ${fnName} after decoration was finished`);
    }
  }

  function assertCallable(fn: any, hint: string) {
    if (typeof fn !== "function") {
      throw new TypeError(`${hint} must be a function`);
    }
  }

  function assertValidReturnValue(kind: number, value: any) {
    if (kind === 1) {
      if (typeof value !== "object" || value === null) {
        throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
      }
      if (value.get !== undefined) {
        assertCallable(value.get, "accessor.get");
      }
      if (value.set !== undefined) {
        assertCallable(value.set, "accessor.set");
      }
      if (value.init !== undefined) {
        assertCallable(value.init, "accessor.init");
      }
    } else if (typeof value !== "function") {
      const hint = kind === 0 ? "field" : kind === 10 ? "class" : "method";
      throw new TypeError(`${hint} decorators must return a function or void 0`);
    }
  }

  function applyMemberDec(
    ret: any[],
    base: object,
    decInfo: any[],
    name: string | symbol,
    kind: number,
    isStatic: boolean,
    isPrivate: boolean,
    initializers: any[]
  ) {
    const decs = Array.isArray(decInfo[0]) ? decInfo[0] : [decInfo[0]];
    let desc, init, value;

    if (isPrivate) {
      if (kind === 0 || kind === 1) {
        desc = {
          get: decInfo[3],
          set: decInfo[4]
        };
      } else if (kind === 3) {
        desc = {
          get: decInfo[3]
        };
      } else if (kind === 4) {
        desc = {
          set: decInfo[3]
        };
      } else {
        desc = {
          value: decInfo[3]
        };
      }
    } else if (kind !== 0) {
      desc = Object.getOwnPropertyDescriptor(base, name);
    }

    if (kind === 1) {
      value = {
        get: desc.get,
        set: desc.set
      };
    } else if (kind === 2) {
      value = desc.value;
    } else if (kind === 3) {
      value = desc.get;
    } else if (kind === 4) {
      value = desc.set;
    }

    let newValue, get, set;
    for (let i = 0; i < decs.length; i++) {
      const dec = decs[i];
      newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, value);
      if (newValue !== undefined) {
        assertValidReturnValue(kind, newValue);
        if (kind === 0) {
          init = newValue;
        } else if (kind === 1) {
          init = newValue.init;
          get = newValue.get || value.get;

