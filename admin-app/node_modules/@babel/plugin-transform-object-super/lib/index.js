"use strict";

import {
  NodePath,
  Scope,
  types as t
} from "@babel/core";
import {
  DeclarePlugin,
  replaceSupers
} from "@babel/helper-plugin-utils";
import {
  getObjectRef,
  replace
} from "@babel/helper-replace-supers";

const transformObjectSuper: DeclarePlugin = (api, opts, dirname) => {
  api.assertVersion(7);

  const newLets = new Set<{
    scopePath: NodePath<t.Scope | t.Loop | t.Function>;
    id: t.Identifier;
  }>();

  return {
    name: "transform-object-super",
    visitor: {
      Loop: {
        exit(path: NodePath<t.Loop>) {
          newLets.forEach(v => {
            if (v.scopePath === path) {
              path.scope.push({
                id: v.id,
                kind: "let"
              });
              path.scope.crawl();
              path.requeue();
              newLets.delete(v);
            }
          });
        }
      },
      ObjectExpression(path: NodePath<t.ObjectExpression>, state) {
        let objectRef;
        const getObjectRef = () => objectRef = objectRef || path.scope.generateUidIdentifier("obj");

        path.get("properties")
          .filter(propPath => propPath.isMethod())
          .forEach(propPath => replacePropertySuper(propPath, getObjectRef, state.file));

        if (objectRef) {
          const scopePath = path.findParent(p => p.isFunction() || p.isProgram() || p.isLoop());
          const useLet = scopePath.isLoop();

          if (useLet) {
            newLets.add({
              scopePath,
              id: t.cloneNode(objectRef)
            });
          } else {
            path.scope.push({
              id: t.cloneNode(objectRef),
              kind: "var"
            });
          }

          path.replaceWith(t.assignmentExpression("=", t.cloneNode(objectRef), path.node));
          return;
        }
      }
    }
  };
};

export default transformObjectSuper;

//# sourceMappingURL=index.js.map
