"use strict";

import { PluginPass, types as t } from "@babel/core";
import { declare } from "@babel/helper-plugin-utils";
import { parse as parseDecorators } from "@babel/helper-decorators";
import { parse as parseDecoratorsLegacy } from "@babel/helper-decorators-legacy";
import { parse as parseDecoratorAutoAccessors } from "@babel/helper-decorator-auto-accessors";

export const defaultOptions = {
  version: "2018-09",
  legacy: false,
  decoratorsBeforeExport: true,
  noVersion: false,
};

export default declare((api, options) => {
  api.assertVersion(7);

  const opts = Object.assign({}, defaultOptions, options);

  if (opts.noVersion) {
    throw new Error(".noVersion option is not supported. Use .version or .legacy instead.");
  }

  const { version } = opts;
  if (version !== "2023-05" && version !== "2023-01" && version !== "2022-03" && version !== "2021-12" && version !== "2018-09" && version !== "legacy") {
    throw new Error(`Unsupported decorators version: ${version}`);
  }

  const { legacy, decoratorsBeforeExport } = opts;
  if (legacy !== undefined) {
    if (typeof legacy !== "boolean") {
      throw new Error(".legacy must be a boolean.");
    }
    if (version !== undefined) {
      throw new Error("You can either use the .legacy or the .version option, not both.");
    }
    version = legacy ? "legacy" : "2018-09";
  }

  if (version === "legacy") {
    return {
      name: "syntax-decorators",
      manipulateOptions(options, parserOptions) {
        parserOptions.plugins.push("decorators-legacy");
      },
    };
  }

  const decoratorsPlugin = ["decorators", { allowCallParenthesized: false }];
  if (version === "2023-01" || version === "2023-05") {
    decoratorsPlugin.push("decoratorAutoAccessors");
  } else if (version === "2022-03") {
    decoratorsPlugin.push({ decoratorsBeforeExport: false, allowCallParenthesized: false });
  } else if (version === "2021-12") {
    decoratorsPlugin.push({ decoratorsBeforeExport });
  }

  return {
    name: "syntax-decorators",
    manipulateOptions(options, parserOptions) {
      parserOptions.plugins.push(decoratorsPlugin);
      if (version === "2021-12" || version === "2022-03") {
        options.generatorOpts.decoratorsBeforeExport = false;
      }
    },
    visitor: {
      ClassDeclaration(path, state) {
        const { node } = path;
        if (version === "legacy") {
          parseDecoratorsLegacy(path, state);
        } else {
          parseDecorators(path, state, { allowCallParenthesized: false });
        }
      },
    },
  };
});

//# sourceMappingURL=index.js.map
