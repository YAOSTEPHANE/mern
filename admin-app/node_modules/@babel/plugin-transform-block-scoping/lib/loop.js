import * as babel from "@babel/core";

const collectLoopBodyBindingsVisitor = {
  Expression(path) {
    path.skip();
  },
  Declaration(path, state) {
    if (path.node.kind === "let" || path.node.kind === "const" || path.node.kind === "hoisted") {
      state.blockScoped.push(path.node);
    }
  },
  Loop(path, state) {
    if (path.isFunctionParent()) path.skip();
    const { bindings } = path.scope;
    for (const name of Object.keys(bindings)) {
      const binding = bindings[name];
      if (binding.kind === "let" || binding.kind === "const" || binding.kind === "hoisted") {
        state.blockScoped.push(binding);
      }
    }
  }
};

function getLoopBodyBindings(loopPath) {
  const state = { blockScoped: [] };
  loopPath.traverse(collectLoopBodyBindingsVisitor, state);
  return state.blockScoped;
}

function getUsageInBody(binding, loopPath) {
  const seen = new WeakSet();
  let capturedInClosure = false;
  const constantViolations = binding.constantViolations.flatMap(path => {
    const { inBody, inClosure } = relativeLoopLocation(path, loopPath);
    if (!inBody) return [];
    capturedInClosure || (capturedInClosure = inClosure);
    const id = path.isUpdateExpression() ? path.get("argument") : path.isAssignmentExpression() ? path.get("left") : null;
    if (id) seen.add(id.node);
    return id ? [id.node] : [];
  });
  const references = binding.referencePaths.flatMap(path => {
    if (seen.has(path.node)) return [];
    const { inBody, inClosure } = relativeLoopLocation(path, loopPath);
    if (!inBody) return [];
    capturedInClosure || (capturedInClosure = inClosure);
    return [path.node];
  });
  return {
    capturedInClosure,
    hasConstantViolations: constantViolations.length > 0,
    usages: references.concat(constantViolations)
  };
}

function relativeLoopLocation(path, loopPath) {
  const bodyPath = loopPath.body;
  let inClosure = false;
  for (let currPath = path; currPath; currPath = currPath.parentPath) {
    if (currPath.isFunction() || currPath.isClass() || currPath.isMethod()) {
      inClosure = true;
    }
    if (currPath === bodyPath) {
      return { inBody: true, inClosure };
    } else if (currPath === loopPath) {
      return { inBody: false, inClosure };
    }
  }
  throw new Error("Internal Babel error: path is not in loop. Please report this as a bug.");
}

const collectCompletionsAndVarsVisitor = {
  Function(path) {
    path.skip();
  },
  LabeledStatement: {
    enter({ node }, state) {
      state.labelsStack.push(node.label.name);
    },
    exit({ node }, state) {
      const popped = state.labelsStack.pop();
      if (popped !== node.label.name) {
        throw new Error("Assertion failure. Please report this bug to Babel.");
      }
    }
  },
  Loop: {
    enter(_, state) {
      state.labellessContinueTargets++;
      state.labellessBreakTargets++;
    },
    exit(_, state) {
      state.labellessContinueTargets--;
      state.labellessBreakTargets--;
    }
  },
  SwitchStatement: {
    enter(_, state) {
      state.labellessBreakTargets++;
    },
    exit(_, state) {
      state.labellessBreakTargets--;
    }
  },
  "BreakStatement|ContinueStatement"(path, state) {
    const { label } = path.node;
    if (label) {
      if (state.labelsStack.includes(label.name)) return;
    } else if (path.isBreakStatement() ? state.labellessBreakTargets > 0 : state.labellessContinueTargets > 0) {
      return;
    }
    state.breaksContinues.push(path);
  },
  ReturnStatement(path, state) {
    state.returns.push(path);
  },
  VariableDeclaration(path, state) {
    if (path.parent === state.loopNode && isVarInLoopHead(path)) return;
    if (
