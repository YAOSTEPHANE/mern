"use strict";

import type { NodePath, Scope, TemplateElement, TemplateLiteral } from "@babel/core";
import type { Node } from "@babel/types";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformWithoutHelper = transformWithoutHelper;

const buildForOfLoose = (
  {
    LOOP_OBJECT,
    IS_ARRAY,
    OBJECT,
    INDEX,
    ID,
    INTERMEDIATE
  }: {
    LOOP_OBJECT: Node;
    IS_ARRAY: Node;
    OBJECT: Node;
    INDEX: Node;
    ID: Node;
    INTERMEDIATE: Node | null;
  }
): TemplateLiteral =>
  _core.template.statement(`
  for (var ${LOOP_OBJECT.name} = ${OBJECT},
          ${IS_ARRAY.name} = Array.isArray(${LOOP_OBJECT.name}),
          ${INDEX.name} = 0,
          ${LOOP_OBJECT.name} = ${IS_ARRAY.name} ? ${LOOP_OBJECT.name} : ${LOOP_OBJECT.name}[Symbol.iterator]();;) {
    ${INTERMEDIATE};
    if (${IS_ARRAY.name}) {
      if (${INDEX.name} >= ${LOOP_OBJECT.name}.length) break;
      ${ID.name} = ${LOOP_OBJECT.name}[${INDEX.name}++];
    } else {
      ${INDEX.name} = ${LOOP_OBJECT.name}.next();
      if (${INDEX.name}.done) break;
      ${ID.name} = ${INDEX.name}.value;
    }
  }
`);

const buildForOf = (
  {
    ITERATOR_COMPLETION,
    ITERATOR_HAD_ERROR_KEY,
    ITERATOR_ERROR_KEY,
    ITERATOR_KEY,
    STEP_KEY,
    OBJECT
  }: {
    ITERATOR_COMPLETION: Node;
    ITERATOR_HAD_ERROR_KEY: Node;
    ITERATOR_ERROR_KEY: Node;
    ITERATOR_KEY: Node;
    STEP_KEY: Node;
    OBJECT: Node;
  }
): TemplateLiteral =>
  _core.template.statements(`
  var ${ITERATOR_COMPLETION.name} = true;
  var ${ITERATOR_HAD_ERROR_KEY.name} = false;
  var ${ITERATOR_ERROR_KEY.name} = undefined;
  try {
    for (
      var ${ITERATOR_KEY.name} = ${OBJECT}[Symbol.iterator](), ${STEP_KEY.name};
      !(<boolean>${ITERATOR_COMPLETION.name} = (<{done: boolean, value: Node}>${STEP_KEY.name} = ${ITERATOR_KEY.name}.next()).done);
      ${ITERATOR_COMPLETION.name} = true
    ) {}
  } catch (err) {
    ${ITERATOR_HAD_ERROR_KEY.name} = true;
    ${ITERATOR_ERROR_KEY.name} = err;
  } finally {
    try {
      if (!<boolean>${ITERATOR_COMPLETION.name} && ${ITERATOR_KEY.name}.return != null) {
        ${ITERATOR_KEY.name}.return();
      }
    } finally {
      if (${ITERATOR_HAD_ERROR_KEY.name}) {
        throw ${ITERATOR_ERROR_KEY.name};
      }
    }
  }
`);

function pushComputedPropsLoose(
  path: NodePath<Node>,
  state: {
    buildCodeFrameError(node: Node, message: string): void;
    scope: Scope;
  }
): {
  replaceParent: boolean;
  declar: Node | null;
  node: Node;
  loop: Node;
} {
  const { node, scope, parent } = path;
  const { left } = node;
  let declar, id, intermediate;
  if (
    _core.types.isIdentifier(left) ||
    _core.types.isPattern(left) ||
    _core.types.isMemberExpression(left)
  ) {
    id = left;
    intermediate = null;
  } else if (_core.types.isVariableDeclaration(left)) {
    id = scope.generateUidIdentifier("ref");
    declar = _core.types.variableDeclaration(left.kind, [
      _core.types.variableDeclarator(
        left.declarations[0].id,
        _core.types.identifier(id.name)
      )
    ]);
    intermediate = _core.types.variableDeclaration("var", [
      _core.types.variableDeclarator(_core.types.identifier(id.name))
    ]);
  } else {
    throw state.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
  }
  const iteratorKey = scope.generateUidIdentifier("iterator");
  const isArrayKey = scope.generateUidIdentifier("isArray");
  const loop = buildForOfLoose({
    LOOP_OBJECT: iteratorKey,
    IS_ARRAY: isArrayKey,
    OBJECT: node.right,
    INDEX: scope.generateUidIdentifier("i"),
    ID: id,
    INTERMEDIATE: intermediate
  });
  const isLabeledParent = _core.types.isLabeledStatement(parent);
  let labeled;
  if (isLabeledParent) {
    labeled = _core.types.labeledStatement(parent.label, loop);
  }
  return {
    replaceParent: isLabeledParent,
    declar: declar,
    node
