import type { Node } from 'postcss-value-parser';

/**
 * Doubles the position gradients in the given node.
 * @param node - The node to modify.
 * @returns An array of any errors encountered during processing.
 */
export declare function doublePositionGradients(node: Node): string[];

/**
 * A helper function to check if a node is a position gradient.
 * @param node - The node to check.
 * @returns True if the node is a position gradient, false otherwise.
 */
function isPositionGradient(node: Node): boolean {
  return node.type === 'function' && node.value === 'linear-gradient' && node.nodes.some((child) => child.type === 'word' && ['to', 'top', 'right', 'bottom', 'left'].includes(child.value));
}

/**
 * Doubles the position gradients in the given node.
 * @param node - The node to modify.
 * @returns An array of any errors encountered during processing.
 */
export declare function doublePositionGradients(node: Node): string[] {
  const errors: string[] = [];

  if (node.type === 'gradient') {
    for (let i = 0; i < node.nodes.length; i++) {
      const child = node.nodes[i];
      if (isPositionGradient(child)) {
        const newChild = child.clone();
        newChild.nodes = child.nodes.map((grandChild) => grandChild.clone());
        node.nodes.splice(i + 1, 0, newChild);
        i++;
      }
    }
  } else {
    node.nodes.forEach((child) => doublePositionGradients(child));
  }

  return errors;
}
