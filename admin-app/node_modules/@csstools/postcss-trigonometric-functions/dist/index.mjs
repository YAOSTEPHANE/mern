import postcssValueParser from "postcss-value-parser";
import { create } from "vm";

const trigonometricFunctions = [
  {
    check: "asin(",
    transform: (node) => {
      const ast = postcssValueParser(node.value);
      ast.walk((node) => {
        if (
          node.type !== "function" ||
          node.value.toLowerCase() !== "asin"
        )
          return;
        const [value] = m(node, false);
        if (value === undefined) return;
        let result = Math.asin(value);
        if (isNaN(result) || typeof result !== "number") {
          result = "NaN";
        } else {
          result = `${n(result)}deg`;
        }
        node.value = result;
      });
      return ast.toString();
    },
  },
  // ... other trigonometric functions
];

const unitMap = {
  deg: (value) => value * (Math.PI / 180),
  grad: (value) => value * (Math.PI / 200),
  rad: (value) => value,
  turn: (value) => value * 2 * Math.PI,
};

const m = (node, allowUnits = true) => {
  // ... implementation of m function
};

const n = (value) => (value * 180) / Math.PI;

const isNumberNode = (node) =>
  node.type === "word" && !isNaN(parseFloat(node.value)) && isFinite(node.value);

const isOperation = (value) => ["+", "-", "*", "/"].includes(value);

const isUnit = (node) => !isNaN(node.number);

const transformUnits = (node) => {
  // ... implementation of transformUnits function
};

const plugin = (options) => {
  const preserve = options.preserve;
  return {
    postcssPlugin: "postcss-trigonometric-functions",
    Declaration(decl) {
      const trigFunc = trigonometricFunctions.find((func) =>
        decl.value.toLowerCase().includes(func.check)
      );
      if (!trigFunc) return;
      const ast = postcssValueParser(decl.value);
      trigFunc.transform(ast);
      if (ast.toString() !== decl.value) {
        decl.before(ast);
        if (!preserve) decl.remove();
      }
    },
  };
};

plugin.postcss = true;
export default plugin;
