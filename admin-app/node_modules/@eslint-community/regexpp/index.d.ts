// Generated by dts-bundle v0.7.3

declare module "@eslint-community/regexpp" {
  import * as AST from "@eslint-community/regexpp/ast";
  import { RegExpParser } from "@eslint-community/regexpp/parser";
  import { RegExpValidator } from "@eslint-community/regexpp/validator";
  import { RegExpVisitor } from "@eslint-community/regexpp/visitor";
  export { RegExpSyntaxError } from "@eslint-community/regexpp/regexp-syntax-error";
  export { AST, RegExpParser, RegExpValidator };
  export function parseRegExpLiteral(
    source: RegExp | string,
    options?: RegExpParser.Options
  ): AST.RegExpLiteral;
  export function validateRegExpLiteral(
    source: string,
    options?: RegExpValidator.Options
  ): void;
  export function visitRegExpAST(
    node: AST.Node,
    handlers: RegExpVisitor.Handlers
  ): void;
}

declare module "@eslint-community/regexpp/ast" {
  export type Node = BranchNode | LeafNode;
  export type BranchNode =
    | Alternative
    | CapturingGroup
    | CharacterClass
    | CharacterClassRange
    | ClassIntersection
    | ClassStringDisjunction
    | ClassSubtraction
    | ExpressionCharacterClass
    | Group
    | LookaroundAssertion
    | Pattern
    | Quantifier
    | RegExpLiteral
    | StringAlternative;
  export type LeafNode =
    | Backreference
    | BoundaryAssertion
    | Character
    | CharacterSet
    | Flags;
  export type Element = Assertion | QuantifiableElement | Quantifier;
  export type QuantifiableElement =
    | Backreference
    | CapturingGroup
    | Character
    | CharacterClass
    | StringCharacterClass
    | Group
    | LookaheadAssertion;
  export type CharacterClassElement =
    | ClassRangesCharacterClassElement
    | UnicodeSetsCharacterClassElement;
  export type ClassRangesCharacterClassElement =
    | Character
    | CharacterClassRange
    | CharacterUnicodePropertyCharacterSet
    | EscapeCharacterSet;
  export type UnicodeSetsCharacterClassElement =
    | Character
    | CharacterClassRange
    | ClassStringDisjunction
    | EscapeCharacterSet
    | ExpressionCharacterClass
    | UnicodePropertyCharacterSet
    | UnicodeSetsCharacterClass;
  export interface NodeBase {
    type: Node["type"];
    parent: Node["parent"];
    start: number;
    end: number;
    raw: string;
  }
  export interface RegExpLiteral extends NodeBase {
    type: "RegExpLiteral";
    parent: null;
    pattern: Pattern;
    flags: Flags;
  }
  export interface Pattern extends NodeBase {
    type: "Pattern";
    parent: RegExpLiteral | null;
    alternatives: Alternative[];
  }
  export interface Alternative extends NodeBase {
    type: "Alternative";
    parent: CapturingGroup | Group | LookaroundAssertion | Pattern;
    elements: Element[];
  }
  export interface Group extends NodeBase {
    type: "Group";
    parent: Alternative | Quantifier;
    alternatives: Alternative[];
  }
  export interface CapturingGroup extends NodeBase {
    type: "CapturingGroup";
    parent: Alternative | Quantifier;
    name: string | null;
    alternatives: Alternative[];
    references: Backreference[];
  }
  export type LookaroundAssertion = LookaheadAssertion | LookbehindAssertion;
  export interface LookaheadAssertion extends NodeBase {
    type: "Assertion";
    parent: Alternative | Quantifier;
    kind: "lookahead";
    negate: boolean;
    alternatives: Alternative[];
  }
  export interface LookbehindAssertion extends NodeBase {
    type: "Assertion";
    parent: Alternative;
    kind: "lookbehind";
    negate: boolean;
    alternatives: Alternative[];
  }
  export interface Quantifier extends NodeBase {
    type: "Quantifier";
    parent: Alternative;
    min: number;
    max: number;
    greedy: boolean;
    element: QuantifiableElement;
  }
  export type CharacterClass =
    | ClassRangesCharacterClass
    | UnicodeSetsCharacterClass;
  interface BaseCharacterClass extends NodeBase {
    type: "CharacterClass";
    parent:
      | Alternative
      | ClassIntersection
      | ClassSubtraction
      | Quantifier
      | UnicodeSetsCharacterClass;
    unicodeSets: boolean;
    negate: boolean;
    elements: CharacterClassElement[];
  }
  export interface ClassRangesCharacterClass extends BaseCharacterClass {
    parent: Alternative | Quantifier;
    unicodeSets: false;
    elements: ClassRangesCharacterClassElement[];
  }
  export interface UnicodeSetsCharacterClass extends BaseCharacterClass {
    parent:
      | Alternative
      | ClassIntersection
      | ClassSubtraction
      | Quantifier
      | UnicodeSetsCharacterClass;
    unicodeSets: true;
    elements: UnicodeSetsCharacterClassElement[];
  }
  export interface CharacterClassRange extends NodeBase {
    type: "CharacterClassRange";
    parent: CharacterClass;
    min: Character;
    max: Character;
  }
  export type Assertion = BoundaryAssertion | LookaroundAssertion;
  export type BoundaryAssertion = EdgeAssertion | WordBoundaryAssertion;
  export interface EdgeAssertion extends NodeBase {
    type: "Assertion";
    parent: Alternative | Quantifier;
    kind: "end" | "start";
 
