'use strict';

const stringWidth = require('string-width-cjs');
const stripAnsi = require('strip-ansi-cjs');
const wrap = require('wrap-ansi-cjs');

function _minWidth(col) {
  const padding = col.padding || [];
  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
  if (col.border) {
    return minWidth + 4;
  }
  return minWidth;
}

function getWindowWidth() {
  if (typeof process === 'object' && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }
  return 80;
}

interface ICol {
  text: string;
  padding?: [number, number, number, number];
  width?: number;
  align?: 'left' | 'right' | 'center';
  border?: boolean;
}

interface IRow extends Array<ICol> {}

interface IUIOptions {
  width?: number;
  wrap?: boolean;
}

class UI {
  width: number;
  wrap: boolean;
  rows: IRow[];

  constructor(opts: IUIOptions) {
    this.width = opts.width || getWindowWidth();
    this.wrap = opts.wrap || true;
    this.rows = [];
  }

  span(...args: string[]): void {
    const cols = this.div(...args);
    cols.span = true;
  }

  resetOutput(): void {
    this.rows = [];
  }

  div(...args: (string | ICol)[]): IRow {
    if (args.length === 0) {
      this.div('');
    }
    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
      return this.applyLayoutDSL(args[0]);
    }
    const cols = args.map((arg) => {
      if (typeof arg === 'string') {
        return this.colFromString(arg);
      }
      return arg;
    });
    this.rows.push(cols);
    return cols;
  }

  shouldApplyLayoutDSL(...args: any[]): boolean {
    return args.length === 1 && typeof args[0] === 'string' && /[\t\n]/.test(args[0]);
  }

  applyLayoutDSL(str: string): IRow {
    const rows = str.split('\n').map((row) => row.split('\t'));
    let leftColumnWidth = 0;
    // simple heuristic for layout, make sure the
    // second column lines up along the left-hand.
    // don't allow the first column to take up more
    // than 50% of the screen.
    rows.forEach((columns) => {
      if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {
        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), stringWidth(columns[0]));
      }
    });
    // generate a table:
    //  replacing ' ' with padding calculations.
    //  using the algorithmically generated width.
    rows.forEach((columns) => {
      this.div(...columns.map((r, i) => {
        return {
          text: r.trim(),
          padding: this.measurePadding(r),
          width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined,
          align: 'left'
        };
      }));
    });
    return this.rows[this.rows.length - 1];
  }

  colFromString(text: string): ICol {
    return {
      text,
      padding: this.measurePadding(text)
    };
  }

  measurePadding(str: string): [number, number, number, number] {
    // measure padding without ansi escape codes
    const noAnsi = stripAnsi(str);
    return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
  }

  toString(): string {
    const lines = [];
    this.rows.forEach((row) => {
      this.rowToString(row, lines);
    });
    // don't display any lines with the
    // hidden flag set.
    return lines
      .filter((line) => !line.hidden)
      .map((line) => line.text)
      .join('\n');
  }

  rowToString(row: IRow, lines: { text: string, hidden: boolean, span: boolean }[]): void {
    this.rasterize(row).forEach((rrow, r) => {
      let str = '';
      rrow.forEach((col, c) => {
        const { width } = row[c]; // the width with padding.
        const wrapWidth = this.negatePadding(row[c]); // the width without padding.
        let ts = col; // temporary string used during alignment/padding.
        if (wrapWidth > stringWidth(col)) {
          ts += ' '.repeat(wrapWidth - stringWidth(col));
        }
        // align the string within its column.
        if (row[c].align && row[c].align !== 'left' && this.wrap) {
          const fn = align[row[c].align];
          ts = fn(ts, wrapWidth);
          if (stringWidth(ts) < wrapWidth) {
            ts += ' '.repeat(width - stringWidth(ts) - 1);
          }
        }
        // apply border and padding to string.
        const padding = row[c].padding || [0, 0, 0, 0];
        if (padding[left]) {
          str
