import stringWidth from 'string-width';
import stripAnsi from 'strip-ansi';
import ansiStyles from 'ansi-styles';

const ESCAPE_CODE_SET = new Set(['\u001B', '\u009B']);
const END_CODE = 39;
const ANSI_ESCAPE_BELL = '\u0007';
const ANSI_CSI = '[';
const ANSI_OSC = ']';
const ANSI_SGR_TERMINATOR = 'm';
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;

const wrapAnsiCode = (code: string) => `${ESCAPE_CODE_SET.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = (uri: string) => `${ESCAPE_CODE_SET.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;

const getWordLengths = (str: string) => str.split(' ').map(word => stringWidth(stripAnsi(word)));

const wrapLongWord = (rows: string[], word: string, columns: number) => {
  const characters = word.split('');
  let visibleLength = 0;

  for (let i = 0; i < characters.length; i++) {
    const character = characters[i];
    const characterLength = stringWidth(character);

    if (visibleLength + characterLength <= columns) {
      rows[rows.length - 1] += character;
    } else {
      rows.push(character);
      visibleLength = 0;
    }

    if (ESCAPE_CODE_SET.has(character)) {
      let isInsideLinkEscape = false;

      if (i + 1 < characters.length) {
        isInsideLinkEscape = characters.slice(i + 1).join('').startsWith(ANSI_ESCAPE_LINK);
      }

      if (isInsideLinkEscape) {
        if (character === ANSI_ESCAPE_BELL) {
          i += 2;
        }
      } else if (character === ANSI_SGR_TERMINATOR) {
        i += 1;
      }
    }

    visibleLength += characterLength;

    if (visibleLength === columns && i < characters.length - 1) {
      rows.push('');
      visibleLength = 0;
    }
  }

  if (rows[rows.length - 1].length === 0) {
    rows.pop();
  }
};

const trimSpacesRight = (str: string) => {
  const words = str.split(' ');
  let last = words.length;

  while (last > 0) {
    if (stringWidth(words[last - 1]) > 0) {
      break;
    }

    last--;
  }

  if (last === words.length) {
    return str;
  }

  return words.slice(0, last).join(' ') + words.slice(last).join('');
};

const exec = (str: string, columns: number, options = {}) => {
  if (options.trim !== false && str.trim() === '') {
    return '';
  }

  let result = '';
  let escapeCode;
  let escapeUrl;

  const lengths = getWordLengths(str);
  let rows = [''];

  for (let i = 0; i < str.split(' ').length; i++) {
    const word = str.split(' ')[i];

    if (options.trim !== false) {
      rows[rows.length - 1] = rows[rows.length - 1].trimStart();
    }

    let rowLength = stringWidth(rows[rows.length - 1]);

    if (i !== 0) {
      if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
        // If we start with a new word but the current row length equals the length of the columns, add a new row
        rows.push('');
        rowLength = 0;
      }

      if (rowLength > 0 || options.trim === false) {
        rows[rows.length - 1] += ' ';
        rowLength++;
      }
    }

    if (rows.length - 1 >= 0) {
      const wordLength = lengths[i];

      if (options.hard && wordLength > columns) {
        const remainingColumns = columns - rowLength;
        const breaksStartingThisLine = 1 + Math.floor((wordLength - remainingColumns - 1) / columns);
        const breaksStartingNextLine = Math.floor(wordLength / columns);

        if (breaksStartingNextLine < breaksStartingThisLine) {
          rows.push('');
        }

        wrapLongWord(rows, word, columns);
        continue;
      }

      if (rowLength + wordLength > columns && rowLength > 0 && wordLength > 0) {
        if (options.wordWrap === false && rowLength < columns) {
          wrapLongWord(rows, word, columns);
          continue;
        }

        rows.push('');
      }

      if (rowLength + wordLength > columns && options.wordWrap === false) {
        wrapLongWord(rows, word, columns);
        continue;
      }

      rows[rows.length - 1] += word
