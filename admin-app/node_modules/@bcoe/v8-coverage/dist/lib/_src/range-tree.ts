import { RangeCov } from "./types";

export class RangeTree {
  start: number;
  end: number;
  delta: number;
  children: RangeTree[];

  constructor(
    start: number,
    end: number,
    delta: number,
    children: RangeTree[] = [],
  ) {
    this.start = start;
    this.end = end;
    this.delta = delta;
    this.children = children;
  }

  static fromSortedRanges(ranges: ReadonlyArray<RangeCov>): RangeTree | undefined {
    if (ranges.length === 0) return undefined;

    const stack: [RangeTree, number][] = [[new RangeTree(ranges[0].startOffset, ranges[0].endOffset, ranges[0].count), ranges[0].count]];

    for (let i = 1; i < ranges.length; i++) {
      const range = ranges[i];
      const [parent, parentCount] = stack[stack.length - 1];

      if (range.startOffset < parent.end) {
        const node = new RangeTree(range.startOffset, range.endOffset, range.count);
        node.delta -= parentCount;
        parent.children.push(node);
        stack.push([node, range.count]);
      } else {
        stack.push([new RangeTree(range.startOffset, range.endOffset, range.count), range.count]);
      }
    }

    return stack[0][0];
  }

  normalize(): void {
    const children: RangeTree[] = [];
    let curEnd: number | undefined;
    let head: RangeTree | undefined;
    const tail: RangeTree[] = [];

    for (const child of this.children) {
      if (head === undefined) {
        head = child;
      } else if (child.delta === head.delta && child.start === curEnd) {
        tail.push(child);
      } else {
        this.connectTailToHead(head, tail);
        head = child;
        tail.length = 0;
      }
      curEnd = child.end;
    }

    if (head !== undefined) {
      this.connectTailToHead(head, tail);
    }

    this.children = children;
  }

  private connectTailToHead(head: RangeTree, tail: RangeTree[]): void {
    if (tail.length > 0) {
      head.end = tail[tail.length - 1].end;
      for (const tailTree of tail) {
        for (const subChild of tailTree.children) {
          subChild.delta += tailTree.delta - head.delta;
          head.children.push(subChild);
        }
      }
    }
    head.normalize();
    children.push(head);
  }

  split(value: number): RangeTree {
    const leftChildren: RangeTree[] = [];
    let mid: RangeTree | undefined;

    for (const child of this.children) {
      if (child.start < value && value < child.end) {
        mid = child.split(value);
      }
      if (child.start < value) {
        leftChildren.push(child);
      }
    }

    const rightChildren: RangeTree[] = this.children.filter(child => child.start >= value);
    if (mid !== undefined) {
      rightChildren.unshift(mid);
    }

    const result = new RangeTree(
      value,
      this.end,
      this.delta,
      rightChildren,
    );

    this.end = value;
    this.children = leftChildren;

    return result;
  }

  toRanges(): RangeCov[] {
    const ranges: RangeCov[] = [];
    const stack: [RangeTree, number][] = [[this, 0]];

    while (stack.length > 0) {
      const [cur, parentCount] = stack.pop()!;
      const count = parentCount + cur.delta;
      ranges.push({startOffset: cur.start, endOffset: cur.end, count});

      for (let i = cur.children.length - 1; i >= 0; i--) {
        stack.push([cur.children[i], count]);
      }
    }

    return ranges;
  }
}
