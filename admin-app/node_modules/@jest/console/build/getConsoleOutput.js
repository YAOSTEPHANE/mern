'use strict';

import chalk from 'chalk';
import { JestMessageUtil } from 'jest-message-util';

interface LogEntry {
  type: string;
  message: string;
  origin: any;
}

interface Config {
  // add type definitions here
}

interface GlobalConfig {
  verbose?: boolean;
  noStackTrace?: boolean;
}

function getConsoleOutput(buffer: LogEntry[], config: Config, globalConfig: GlobalConfig): string {
  const TITLE_INDENT = globalConfig.verbose ? '  ' : '    ';
  const CONSOLE_INDENT = TITLE_INDENT + '  ';

  const logEntries = buffer.reduce((output, { type, message, origin }) => {
    message = message
      .split(/\n/)
      .map(line => CONSOLE_INDENT + line)
      .join('\n');

    let typeMessage = 'console.' + type;
    let noStackTrace = true;
    let noCodeFrame = true;

    if (type === 'warn') {
      const globalConfigNoStackTrace = globalConfig.noStackTrace;

      message = chalk.yellow(message);
      typeMessage = chalk.yellow(typeMessage);

      noStackTrace =
        globalConfigNoStackTrace !== undefined
          ? globalConfigNoStackTrace
          : false;

      noCodeFrame = false;
    } else if (type === 'error') {
      const globalConfigNoStackTrace = globalConfig.noStackTrace;

      message = chalk.red(message);
      typeMessage = chalk.red(typeMessage);

      noStackTrace =
        globalConfigNoStackTrace !== undefined
          ? globalConfigNoStackTrace
          : false;

      noCodeFrame = false;
    }

    const options = {
      noCodeFrame,
      noStackTrace
    };

    const formattedStackTrace = new JestMessageUtil().formatStackTrace(
      origin,
      config,
      options
    );

    return (
      output +
      TITLE_INDENT +
      chalk.dim(typeMessage) +
      '\n' +
      message.trimRight() +
      '\n' +
      chalk.dim(formattedStackTrace.trimRight()) +
      '\n\n'
    );
  }, '');

  return logEntries.trimRight() + '\n';
}
