'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = void 0;

const {ARROW, CLEAR} = require('jest-util').specialChars;
const {pluralize} = require('jest-util');
const ansiEscapes = require('ansi-escapes');
const chalk = require('chalk');
const jestWatcher = require('jest-watcher');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

const {default: _defineProperty} = _interopRequireDefault(require('babel-runtime/helpers/defineProperty'));

class FailedTestsInteractiveMode {
  constructor(_pipe) {
    _defineProperty(this, '_isActive', false);

    _defineProperty(this, '_countPaths', 0);

    _defineProperty(this, '_skippedNum', 0);

    _defineProperty(this, '_testAssertions', []);

    _defineProperty(this, '_updateTestRunnerConfig', void 0);

    this._pipe = _pipe;
  }

  isActive() {
    return this._isActive;
  }

  put(key) {
    switch (key) {
      case 's':
      case 'q':
      case jestWatcher.KEYS.ESCAPE:
      case 'r':
      case jestWatcher.KEYS.ENTER:
        this[key]();
        break;

      default:
        // Ignore other keys
        break;
    }
  }

  run(failedTestAssertions, updateConfig) {
    if (failedTestAssertions.length === 0) return;
    this._testAssertions = failedTestAssertions;
    this._countPaths = this._testAssertions.length;
    this._updateTestRunnerConfig = updateConfig;
    this._isActive = true;

    this._run();
  }

  updateWithResults(results) {
    if (!results.snapshot.failure && results.numFailedTests > 0) {
      return this._drawUIOverlay();
    }

    this._testAssertions.shift();

    if (this._testAssertions.length === 0) {
      return this._drawUIOverlay();
    } // Go to the next test

    return this._run();
  }

  reset() {
    this._isActive = false;
    this._skippedNum = 0;
    this._countPaths = 0;
    this._testAssertions = [];
    this._updateTestRunnerConfig = void 0;
  }

  _clearTestSummary() {
    this._pipe.write(ansiEscapes.cursorUp(6));

    this._pipe.write(ansiEscapes.eraseDown);
  }

  _drawUIDone() {
    this._pipe.write(CLEAR);

    const messages = [
      chalk.bold('Watch Usage'),
      describeKey('Enter', 'to return to watch mode.')
    ];

    this._pipe.write(messages.join('\n') + '\n');
  }

  _drawUIDoneWithSkipped() {
    this._pipe.write(CLEAR);

    let stats = `${pluralize('test', this._countPaths)} reviewed`;

    if (this._skippedNum > 0) {
      const skippedText = chalk.bold.yellow(
        pluralize('test', this._skippedNum) + ' skipped'
      );

      stats = `${stats}, ${skippedText}`;
    }

    const message = [
      TestProgressLabel,
      `${ARROW}${stats}`,
      '\n',
      chalk.bold('Watch Usage'),
      describeKey('r', 'to restart Interactive Mode.'),
      describeKey('q', 'to quit Interactive Mode.'),
      describeKey('Enter', 'to return to watch mode.')
    ];

    this._pipe.write(`\n${message.join('\n')}`);
  }

  _drawUIProgress() {
    this._clearTestSummary();

    const numPass = this._countPaths - this._testAssertions.length;
    const numRemaining = this._countPaths - numPass - this._skippedNum;
    let stats = `${pluralize('test', numRemaining)} remaining`;

    if (this._skippedNum > 0) {
      const skippedText = chalk.bold.yellow(
        pluralize('test', this._skippedNum) + ' skipped'
      );

      stats = `${stats}, ${skippedText}`;
    }

    const message = [
      TestProgressLabel,
      `${ARROW}${stats}`,
      '\n',
      chalk.bold('Watch Usage'),
      describeKey('s', 'to skip the current test.'),
      describeKey('q', 'to quit Interactive Mode.'),
      describeKey('Enter', 'to return to watch mode.')
    ];

    this._pipe.write(`\n${message.join('\n')}`);
  }

  _drawUIOverlay() {
    if (this._testAssertions.length === 0) return this._drawUIDone();
    return this._drawUIProgress();
  }

  _run() {
    if (this._updateTestRunnerConfig) {
      this._updateTestRunnerConfig(this._testAssertions[0]);
    }
  }

  abort() {
    this.reset();

    if (this._updateTestRunnerConfig) {
      this._updateTestRunnerConfig();
    }
  }

  restart() {
    this._skipped
